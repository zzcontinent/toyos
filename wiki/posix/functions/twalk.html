<!-- Copyright 2001-2013 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group's rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2013 The Open Group, All Rights Reserved -->
<title>tdelete</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/tcsetpgrp.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/telldir.html" accesskey="N">Next &gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>

<script type="text/javascript" language="JavaScript" src="../jscript/codes.js">
</script>

<basefont size="3"> 

<center><font size="2">The Open Group Base Specifications Issue 7, 2018 edition<br>
IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)<br>
Copyright &copy; 2001-2018 IEEE and The Open Group</font></center>

<hr size="2" noshade>
<a name="top"></a> <a name="tdelete"></a> <a name="tag_16_609"></a><!-- tdelete -->
 

<h4 class="mansect"><a name="tag_16_609_01"></a>NAME</h4>

<blockquote>tdelete, tfind, tsearch, twalk - manage a binary search tree</blockquote>

<h4 class="mansect"><a name="tag_16_609_02"></a>SYNOPSIS</h4>

<blockquote class="synopsis">
<div class="box"><code><tt><sup>[<a href="javascript:open_code('XSI')">XSI</a>]</sup> <img src="../images/opt-start.gif" alt=
"[Option Start]" border="0"> #include &lt;<a href="../basedefs/search.h.html">search.h</a>&gt;<br>
<br>
 void *tdelete(const void *restrict</tt> <i>key</i><tt>, void **restrict</tt> <i>rootp</i><tt>,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int(*</tt><i>compar</i><tt>)(const void *, const void *));<br>
 void *tfind(const void *</tt><i>key</i><tt>, void *const *</tt><i>rootp</i><tt>,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int(*</tt><i>compar</i><tt>)(const void *, const void *));<br>
 void *tsearch(const void *</tt><i>key</i><tt>, void **</tt><i>rootp</i><tt>,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*</tt><i>compar</i><tt>)(const void *, const void *));<br>
 void twalk(const void *</tt><i>root</i><tt>,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*</tt><i>action</i><tt>)(const void *, VISIT, int)); <img src="../images/opt-end.gif"
alt="[Option End]" border="0"></tt></code></div>

<tt><br>
</tt></blockquote>

<h4 class="mansect"><a name="tag_16_609_03"></a>DESCRIPTION</h4>

<blockquote>
<p>The <i>tdelete</i>(), <i>tfind</i>(), <i>tsearch</i>(), and <i>twalk</i>() functions manipulate binary search trees. Comparisons
are made with a user-supplied routine, the address of which is passed as the <i>compar</i> argument. This routine is called with
two arguments, which are the pointers to the elements being compared. The application shall ensure that the user-supplied routine
returns an integer less than, equal to, or greater than 0, according to whether the first argument is to be considered less than,
equal to, or greater than the second argument. The comparison function need not compare every byte, so arbitrary data may be
contained in the elements in addition to the values being compared.</p>

<p>The <i>tsearch</i>() function shall build and access the tree. The <i>key</i> argument is a pointer to an element to be accessed
or stored. If there is a node in the tree whose element is equal to the value pointed to by <i>key</i>, a pointer to this found
node shall be returned. Otherwise, the value pointed to by <i>key</i> shall be inserted (that is, a new node is created and the
value of <i>key</i> is copied to this node), and a pointer to this node returned. Only pointers are copied, so the application
shall ensure that the calling routine stores the data. The <i>rootp</i> argument points to a variable that points to the root node
of the tree. A null pointer value for the variable pointed to by <i>rootp</i> denotes an empty tree; in this case, the variable
shall be set to point to the node which shall be at the root of the new tree.</p>

<p>Like <i>tsearch</i>(), <i>tfind</i>() shall search for a node in the tree, returning a pointer to it if found. However, if it is
not found, <i>tfind</i>() shall return a null pointer. The arguments for <i>tfind</i>() are the same as for <i>tsearch</i>().</p>

<p>The <i>tdelete</i>() function shall delete a node from a binary search tree. The arguments are the same as for <i>tsearch</i>().
The variable pointed to by <i>rootp</i> shall be changed if the deleted node was the root of the tree. If the deleted node was the
root of the tree and had no children, the variable pointed to by <i>rootp</i> shall be set to a null pointer. The <i>tdelete</i>()
function shall return a pointer to the parent of the deleted node, or an unspecified non-null pointer if the deleted node was the
root node, or a null pointer if the node is not found.</p>

<p>If <i>tsearch</i>() adds an element to a tree, or <i>tdelete</i>() successfully deletes an element from a tree, the concurrent
use of that tree in another thread, or use of pointers produced by a previous call to <i>tfind</i>() or <i>tsearch</i>(), produces
undefined results.</p>

<p>The <i>twalk</i>() function shall traverse a binary search tree. The <i>root</i> argument is a pointer to the root node of the
tree to be traversed. (Any node in a tree may be used as the root for a walk below that node.) The argument <i>action</i> is the
name of a routine to be invoked at each node. This routine is, in turn, called with three arguments. The first argument shall be
the address of the node being visited. The structure pointed to by this argument is unspecified and shall not be modified by the
application, but it shall be possible to cast a pointer-to-node into a pointer-to-pointer-to-element to access the element stored
in the node. The second argument shall be a value from an enumeration data type:</p>

<pre>
<tt>typedef enum { preorder, postorder, endorder, leaf } VISIT;
</tt>
</pre>

<p>(defined in <a href="../basedefs/search.h.html"><i>&lt;search.h&gt;</i></a>), depending on whether this is the first, second, or
third time that the node is visited (during a depth-first, left-to-right traversal of the tree), or whether the node is a leaf. The
third argument shall be the level of the node in the tree, with the root being level 0.</p>

<p>If the calling function alters the pointer to the root, the result is undefined.</p>

<p>If the functions pointed to by <i>action</i> or <i>compar</i> (for any of these binary search functions) change the tree, the
results are undefined.</p>

<p>These functions are thread-safe only as long as multiple threads do not access the same tree.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_609_04"></a>RETURN VALUE</h4>

<blockquote>
<p>If the node is found, both <i>tsearch</i>() and <i>tfind</i>() shall return a pointer to it. If not, <i>tfind</i>() shall return
a null pointer, and <i>tsearch</i>() shall return a pointer to the inserted item.</p>

<p>A null pointer shall be returned by <i>tsearch</i>() if there is not enough space available to create a new node.</p>

<p>A null pointer shall be returned by <i>tdelete</i>(), <i>tfind</i>(), and <i>tsearch</i>() if <i>rootp</i> is a null pointer on
entry.</p>

<p>The <i>tdelete</i>() function shall return a pointer to the parent of the deleted node, or an unspecified non-null pointer if
the deleted node was the root node, or a null pointer if the node is not found.</p>

<p>The <i>twalk</i>() function shall not return a value.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_609_05"></a>ERRORS</h4>

<blockquote>
<p>No errors are defined.</p>
</blockquote>

<hr>
<div class="box"><em>The following sections are informative.</em></div>

<h4 class="mansect"><a name="tag_16_609_06"></a>EXAMPLES</h4>

<blockquote>
<p>The following code reads in strings and stores structures containing a pointer to each string and a count of its length. It then
walks the tree, printing out the stored strings and their lengths in alphabetical order.</p>

<pre>
<tt>#include &lt;limits.h&gt;
#include &lt;search.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
<br>
struct element {      /* Pointers to these are stored in the tree. */
    int     count;
    char    string[];
};
<br>
void  *root = NULL;          /* This points to the root. */
<br>
int main(void)
{
    char   str[_POSIX2_LINE_MAX+1];
    int    length = 0;
    struct element *elementptr;
    void   *node;
    void   print_node(const void *, VISIT, int);
    int    node_compare(const void *, const void *),
           delete_root(const void *, const void *);
<br>
    while (fgets(str, sizeof(str), stdin))  {
        /* Set element. */
        length = strlen(str);
        if (str[length-1] == '\n')
            str[--length] = '\0';
        elementptr = malloc(sizeof(struct element) + length + 1);
        strcpy(elementptr-&gt;string, str);
        elementptr-&gt;count = 1;
        /* Put element into the tree. */
        node = tsearch((void *)elementptr, &amp;root, node_compare);
        if (node == NULL) {
            fprintf(stderr,
                    "tsearch: Not enough space available\n");
            exit(EXIT_FAILURE);
        }
        else if (*(struct element **)node != elementptr) {
            /* A node containing the element already exists */
            (*(struct element **)node)-&gt;count++;
            free(elementptr);
        }
    }
    twalk(root, print_node);
<br>
    /* Delete all nodes in the tree */
    while (root != NULL) {
        elementptr = *(struct element **)root;
        printf("deleting node: string = %s,  count = %d\n",
               elementptr-&gt;string,
               elementptr-&gt;count);
        tdelete((void *)elementptr, &amp;root, delete_root);
        free(elementptr);
    }
<br>
    return 0;
}
<br>
/*
 *  This routine compares two nodes, based on an
 *  alphabetical ordering of the string field.
 */
int
node_compare(const void *node1, const void *node2)
{
    return strcmp(((const struct element *) node1)-&gt;string,
        ((const struct element *) node2)-&gt;string);
}
<br>
/*
 *  This comparison routine can be used with tdelete()
 *  when explicitly deleting a root node, as no comparison
 *  is necessary.
 */
int
delete_root(const void *node1, const void *node2)
{
    return 0;
}
<br>
/*
 *  This routine prints out a node, the second time
 *  twalk encounters it or if it is a leaf.
 */
void
print_node(const void *ptr, VISIT order, int level)
{
    const struct element *p = *(const struct element **) ptr;
<br>
    if (order == postorder || order == leaf)  {
        (void) printf("string = %s,  count = %d\n",
            p-&gt;string, p-&gt;count);
    }
}
</tt>
</pre>
</blockquote>

<h4 class="mansect"><a name="tag_16_609_07"></a>APPLICATION USAGE</h4>

<blockquote>
<p>The <i>root</i> argument to <i>twalk</i>() is one level of indirection less than the <i>rootp</i> arguments to <i>tdelete</i>()
and <i>tsearch</i>().</p>

<p>There are two nomenclatures used to refer to the order in which tree nodes are visited. The <i>twalk</i>() function uses
<b>preorder</b>, <b>postorder</b>, and <b>endorder</b> to refer respectively to visiting a node before any of its children, after
its left child and before its right, and after both its children. The alternative nomenclature uses <b>preorder</b>,
<b>inorder</b>, and <b>postorder</b> to refer to the same visits, which could result in some confusion over the meaning of
<b>postorder</b>.</p>

<p>Since the return value of <i>tdelete</i>() is an unspecified non-null pointer in the case that the root of the tree has been
deleted, applications should only use the return value of <i>tdelete</i>() as indication of success or failure and should not
assume it can be dereferenced. Some implementations in this case will return a pointer to the new root of the tree (or to an empty
tree if the deleted root node was the only node in the tree); other implementations return arbitrary non-null pointers.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_609_08"></a>RATIONALE</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_609_09"></a>FUTURE DIRECTIONS</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_609_10"></a>SEE ALSO</h4>

<blockquote>
<p><a href="../functions/hcreate.html#"><i>hcreate</i></a>, <a href="../functions/lsearch.html#"><i>lsearch</i></a></p>

<p>XBD <a href="../basedefs/search.h.html"><i>&lt;search.h&gt;</i></a></p>
</blockquote>

<h4 class="mansect"><a name="tag_16_609_11"></a>CHANGE HISTORY</h4>

<blockquote>
<p>First released in Issue 1. Derived from Issue 1 of the SVID.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_609_12"></a>Issue 5</h4>

<blockquote>
<p>The last paragraph of the DESCRIPTION was included as an APPLICATION USAGE note in previous issues.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_609_13"></a>Issue 6</h4>

<blockquote>
<p>The normative text is updated to avoid use of the term &quot;must&quot; for application requirements.</p>

<p>The <b>restrict</b> keyword is added to the <i>tdelete</i>() prototype for alignment with the ISO/IEC&nbsp;9899:1999
standard.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_609_14"></a>Issue 7</h4>

<blockquote>
<p>Austin Group Interpretation 1003.1-2001 #149 is applied, clarifying concurrent use of the tree in another thread.</p>

<p>Austin Group Interpretation 1003.1-2001 #151 is applied, clarifying behavior for <i>tdelete</i>() when the deleted node is the
root node.</p>

<p>Austin Group Interpretation 1003.1-2001 #153 is applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0366 [551] is applied.</p>
</blockquote>

<div class="box"><em>End of informative text.</em></div>

<hr>
<p>&nbsp;</p>

<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
Copyright &copy; 2001-2018 IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/tcsetpgrp.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/telldir.html" accesskey="N">Next &gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>
</body>
</html>

