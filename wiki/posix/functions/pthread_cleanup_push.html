<!-- Copyright 2001-2013 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group's rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2013 The Open Group, All Rights Reserved -->
<title>pthread_cleanup_pop</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/pthread_cancel.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/pthread_cond_broadcast.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>


<basefont size="3"> 

<center><font size="2">The Open Group Base Specifications Issue 7, 2018 edition<br>
IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)<br>
Copyright &copy; 2001-2018 IEEE and The Open Group</font></center>

<hr size="2" noshade>
<a name="top"></a> <a name="pthread_cleanup_pop"></a> <a name="tag_16_417"></a><!-- pthread_cleanup_pop -->
 

<h4 class="mansect"><a name="tag_16_417_01"></a>NAME</h4>

<blockquote>pthread_cleanup_pop, pthread_cleanup_push - establish cancellation handlers</blockquote>

<h4 class="mansect"><a name="tag_16_417_02"></a>SYNOPSIS</h4>

<blockquote class="synopsis">
<p><code><tt>#include &lt;<a href="../basedefs/pthread.h.html">pthread.h</a>&gt;<br>
<br>
 void pthread_cleanup_pop(int</tt> <i>execute</i><tt>);<br>
 void pthread_cleanup_push(void (*</tt><i>routine</i><tt>)(void*), void *</tt><i>arg</i><tt>);<br>
</tt></code></p>
</blockquote>

<h4 class="mansect"><a name="tag_16_417_03"></a>DESCRIPTION</h4>

<blockquote>
<p>The <i>pthread_cleanup_pop</i>() function shall remove the routine at the top of the calling thread's cancellation cleanup stack
and optionally invoke it (if <i>execute</i> is non-zero).</p>

<p>The <i>pthread_cleanup_push</i>() function shall push the specified cancellation cleanup handler <i>routine</i> onto the calling
thread's cancellation cleanup stack. The cancellation cleanup handler shall be popped from the cancellation cleanup stack and
invoked with the argument <i>arg</i> when:</p>

<ul>
<li>
<p>The thread exits (that is, calls <a href="../functions/pthread_exit.html"><i>pthread_exit</i>()</a>).</p>
</li>

<li>
<p>The thread acts upon a cancellation request.</p>
</li>

<li>
<p>The thread calls <i>pthread_cleanup_pop</i>() with a non-zero <i>execute</i> argument.</p>
</li>
</ul>

<p>It is unspecified whether <i>pthread_cleanup_push</i>() and <i>pthread_cleanup_pop</i>() are macros or functions. If a macro
definition is suppressed in order to access an actual function, or a program defines an external identifier with any of these
names, the behavior is undefined. The application shall ensure that they appear as statements, and in pairs within the same lexical
scope (that is, the <i>pthread_cleanup_push</i>() macro may be thought to expand to a token list whose first token is <tt>'{'</tt>
with <i>pthread_cleanup_pop</i>() expanding to a token list whose last token is the corresponding <tt>'}'</tt> ).</p>

<p>The effect of calling <a href="../functions/longjmp.html"><i>longjmp</i>()</a> or <a href=
"../functions/siglongjmp.html"><i>siglongjmp</i>()</a> is undefined if there have been any calls to <i>pthread_cleanup_push</i>()
or <i>pthread_cleanup_pop</i>() made without the matching call since the jump buffer was filled. The effect of calling <a href=
"../functions/longjmp.html"><i>longjmp</i>()</a> or <a href="../functions/siglongjmp.html"><i>siglongjmp</i>()</a> from inside a
cancellation cleanup handler is also undefined unless the jump buffer was also filled in the cancellation cleanup handler.</p>

<p>The effect of the use of <b>return</b>, <b>break</b>, <b>continue</b>, and <b>goto</b> to prematurely leave a code block
described by a pair of <i>pthread_cleanup_push</i>() and <i>pthread_cleanup_pop</i>() functions calls is undefined.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_417_04"></a>RETURN VALUE</h4>

<blockquote>
<p>The <i>pthread_cleanup_push</i>() and <i>pthread_cleanup_pop</i>() functions shall not return a value.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_417_05"></a>ERRORS</h4>

<blockquote>
<p>No errors are defined.</p>

<p>These functions shall not return an error code of [EINTR].</p>
</blockquote>

<hr>
<div class="box"><em>The following sections are informative.</em></div>

<h4 class="mansect"><a name="tag_16_417_06"></a>EXAMPLES</h4>

<blockquote>
<p>The following is an example using thread primitives to implement a cancelable, writers-priority read-write lock:</p>

<pre>
<tt>typedef struct {
    pthread_mutex_t lock;
    pthread_cond_t rcond,
        wcond;
    int lock_count; /* &lt; 0 .. Held by writer. */
                    /* &gt; 0 .. Held by lock_count readers. */
                    /* = 0 .. Held by nobody. */
    int waiting_writers; /* Count of waiting writers. */
} rwlock;
<br>
void
waiting_reader_cleanup(void *arg)
{
    rwlock *l;
<br>
    l = (rwlock *) arg;
    pthread_mutex_unlock(&amp;l-&gt;lock);
}
<br>
void
lock_for_read(rwlock *l)
{
    pthread_mutex_lock(&amp;l-&gt;lock);
    pthread_cleanup_push(waiting_reader_cleanup, l);
    while ((l-&gt;lock_count &lt; 0) || (l-&gt;waiting_writers != 0))
        pthread_cond_wait(&amp;l-&gt;rcond, &amp;l-&gt;lock);
    l-&gt;lock_count++;
   /*
    * Note the pthread_cleanup_pop executes
    * waiting_reader_cleanup.
    */
    pthread_cleanup_pop(1);
}
<br>
void
release_read_lock(rwlock *l)
{
    pthread_mutex_lock(&amp;l-&gt;lock);
    if (--l-&gt;lock_count == 0)
        pthread_cond_signal(&amp;l-&gt;wcond);
    pthread_mutex_unlock(&amp;l-&gt;lock);
}
<br>
void
waiting_writer_cleanup(void *arg)
{
    rwlock *l;
<br>
    l = (rwlock *) arg;
    if ((--l-&gt;waiting_writers == 0) &amp;&amp; (l-&gt;lock_count &gt;= 0)) {
       /*
        * This only happens if we have been canceled. If the
        * lock is not held by a writer, there may be readers who
        * were blocked because waiting_writers was positive; they
        * can now be unblocked.
        */
        pthread_cond_broadcast(&amp;l-&gt;rcond);
    }
    pthread_mutex_unlock(&amp;l-&gt;lock);
}
<br>
void
lock_for_write(rwlock *l)
{
    pthread_mutex_lock(&amp;l-&gt;lock);
    l-&gt;waiting_writers++;
    pthread_cleanup_push(waiting_writer_cleanup, l);
    while (l-&gt;lock_count != 0)
        pthread_cond_wait(&amp;l-&gt;wcond, &amp;l-&gt;lock);
    l-&gt;lock_count = -1;
   /*
    * Note the pthread_cleanup_pop executes
    * waiting_writer_cleanup.
    */
    pthread_cleanup_pop(1);
}
<br>
void
release_write_lock(rwlock *l)
{
    pthread_mutex_lock(&amp;l-&gt;lock);
    l-&gt;lock_count = 0;
    if (l-&gt;waiting_writers == 0)
        pthread_cond_broadcast(&amp;l-&gt;rcond);
    else
        pthread_cond_signal(&amp;l-&gt;wcond);
    pthread_mutex_unlock(&amp;l-&gt;lock);
}
<br>
/*
 * This function is called to initialize the read/write lock.
 */
void
initialize_rwlock(rwlock *l)
{
    pthread_mutex_init(&amp;l-&gt;lock, pthread_mutexattr_default);
    pthread_cond_init(&amp;l-&gt;wcond, pthread_condattr_default);
    pthread_cond_init(&amp;l-&gt;rcond, pthread_condattr_default);
    l-&gt;lock_count = 0;
    l-&gt;waiting_writers = 0;
}
<br>
reader_thread()
{
    lock_for_read(&amp;lock);
    pthread_cleanup_push(release_read_lock, &amp;lock);
   /*
    * Thread has read lock.
    */
    pthread_cleanup_pop(1);
}
<br>
writer_thread()
{
    lock_for_write(&amp;lock);
    pthread_cleanup_push(release_write_lock, &amp;lock);
   /*
    * Thread has write lock.
    */
pthread_cleanup_pop(1);
}
</tt>
</pre>
</blockquote>

<h4 class="mansect"><a name="tag_16_417_07"></a>APPLICATION USAGE</h4>

<blockquote>
<p>The two routines that push and pop cancellation cleanup handlers, <i>pthread_cleanup_push</i>() and
<i>pthread_cleanup_pop</i>(), can be thought of as left and right-parentheses. They always need to be matched.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_417_08"></a>RATIONALE</h4>

<blockquote>
<p>The restriction that the two routines that push and pop cancellation cleanup handlers, <i>pthread_cleanup_push</i>() and
<i>pthread_cleanup_pop</i>(), have to appear in the same lexical scope allows for efficient macro or compiler implementations and
efficient storage management. A sample implementation of these routines as macros might look like this:</p>

<pre>
<tt>#define pthread_cleanup_push(rtn,arg) { \
    struct _pthread_handler_rec __cleanup_handler, **__head; \
    __cleanup_handler.rtn = rtn; \
    __cleanup_handler.arg = arg; \
    (void) pthread_getspecific(_pthread_handler_key, &amp;__head); \
    __cleanup_handler.next = *__head; \
    *__head = &amp;__cleanup_handler;
<br>
#define pthread_cleanup_pop(ex) \
    *__head = __cleanup_handler.next; \
    if (ex) (*__cleanup_handler.rtn)(__cleanup_handler.arg); \
}
</tt>
</pre>

<p>A more ambitious implementation of these routines might do even better by allowing the compiler to note that the cancellation
cleanup handler is a constant and can be expanded inline.</p>

<p>This volume of POSIX.1-2017 currently leaves unspecified the effect of calling <a href=
"../functions/longjmp.html"><i>longjmp</i>()</a> from a signal handler executing in a POSIX System Interfaces function. If an
implementation wants to allow this and give the programmer reasonable behavior, the <a href=
"../functions/longjmp.html"><i>longjmp</i>()</a> function has to call all cancellation cleanup handlers that have been pushed but
not popped since the time <a href="../functions/setjmp.html"><i>setjmp</i>()</a> was called.</p>

<p>Consider a multi-threaded function called by a thread that uses signals. If a signal were delivered to a signal handler during
the operation of <a href="../functions/qsort.html"><i>qsort</i>()</a> and that handler were to call <a href=
"../functions/longjmp.html"><i>longjmp</i>()</a> (which, in turn, did <i>not</i> call the cancellation cleanup handlers) the helper
threads created by the <a href="../functions/qsort.html"><i>qsort</i>()</a> function would not be canceled. Instead, they would
continue to execute and write into the argument array even though the array might have been popped off the stack.</p>

<p>Note that the specified cleanup handling mechanism is especially tied to the C language and, while the requirement for a uniform
mechanism for expressing cleanup is language-independent, the mechanism used in other languages may be quite different. In
addition, this mechanism is really only necessary due to the lack of a real exception mechanism in the C language, which would be
the ideal solution.</p>

<p>There is no notion of a cancellation cleanup-safe function. If an application has no cancellation points in its signal handlers,
blocks any signal whose handler may have cancellation points while calling async-unsafe functions, or disables cancellation while
calling async-unsafe functions, all functions may be safely called from cancellation cleanup routines.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_417_09"></a>FUTURE DIRECTIONS</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_417_10"></a>SEE ALSO</h4>

<blockquote>
<p><a href="../functions/pthread_cancel.html#"><i>pthread_cancel</i></a>, <a href=
"../functions/pthread_setcancelstate.html#"><i>pthread_setcancelstate</i></a></p>

<p>XBD <a href="../basedefs/pthread.h.html"><i>&lt;pthread.h&gt;</i></a></p>
</blockquote>

<h4 class="mansect"><a name="tag_16_417_11"></a>CHANGE HISTORY</h4>

<blockquote>
<p>First released in Issue 5. Included for alignment with the POSIX Threads Extension.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_417_12"></a>Issue 6</h4>

<blockquote>
<p>The <i>pthread_cleanup_pop</i>() and <i>pthread_cleanup_push</i>() functions are marked as part of the Threads option.</p>

<p>The APPLICATION USAGE section is added.</p>

<p>The normative text is updated to avoid use of the term &quot;must&quot; for application requirements.</p>

<p>IEEE&nbsp;Std&nbsp;1003.1-2001/Cor&nbsp;2-2004, item XSH/TC2/D6/88 is applied, updating the DESCRIPTION to describe the
consequences of prematurely leaving a code block defined by the <i>pthread_cleanup_push</i>() and <i>pthread_cleanup_pop</i>()
functions.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_417_13"></a>Issue 7</h4>

<blockquote>
<p>The <i>pthread_cleanup_pop</i>() and <i>pthread_cleanup_push</i>() functions are moved from the Threads option to the Base.</p>

<p>POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0454 [229] is applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0268 [624] is applied.</p>
</blockquote>

<div class="box"><em>End of informative text.</em></div>

<hr>
<p>&nbsp;</p>

<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
Copyright &copy; 2001-2018 IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/pthread_cancel.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/pthread_cond_broadcast.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>
</body>
</html>

