<!-- Copyright 2001-2013 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group's rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2013 The Open Group, All Rights Reserved -->
<title>pthread_mutex_destroy</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/pthread_mutex_consistent.html" accesskey=
"P">&lt;&lt;&lt; Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/pthread_mutex_getprioceiling.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>


<basefont size="3"> 

<center><font size="2">The Open Group Base Specifications Issue 7, 2018 edition<br>
IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)<br>
Copyright &copy; 2001-2018 IEEE and The Open Group</font></center>

<hr size="2" noshade>
<a name="top"></a> <a name="pthread_mutex_destroy"></a> <a name="tag_16_437"></a><!-- pthread_mutex_destroy -->
 

<h4 class="mansect"><a name="tag_16_437_01"></a>NAME</h4>

<blockquote>pthread_mutex_destroy, pthread_mutex_init - destroy and initialize a mutex</blockquote>

<h4 class="mansect"><a name="tag_16_437_02"></a>SYNOPSIS</h4>

<blockquote class="synopsis">
<p><code><tt>#include &lt;<a href="../basedefs/pthread.h.html">pthread.h</a>&gt;<br>
<br>
 int pthread_mutex_destroy(pthread_mutex_t *</tt><i>mutex</i><tt>);<br>
 int pthread_mutex_init(pthread_mutex_t *restrict</tt> <i>mutex</i><tt>,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const pthread_mutexattr_t *restrict</tt> <i>attr</i><tt>);<br>
 pthread_mutex_t</tt> <i>mutex</i> <tt>= PTHREAD_MUTEX_INITIALIZER;<br>
</tt></code></p>
</blockquote>

<h4 class="mansect"><a name="tag_16_437_03"></a>DESCRIPTION</h4>

<blockquote>
<p>The <i>pthread_mutex_destroy</i>() function shall destroy the mutex object referenced by <i>mutex</i>; the mutex object becomes,
in effect, uninitialized. An implementation may cause <i>pthread_mutex_destroy</i>() to set the object referenced by <i>mutex</i>
to an invalid value.</p>

<p>A destroyed mutex object can be reinitialized using <i>pthread_mutex_init</i>(); the results of otherwise referencing the object
after it has been destroyed are undefined.</p>

<p>It shall be safe to destroy an initialized mutex that is unlocked. Attempting to destroy a locked mutex, or a mutex that another
thread is attempting to lock, or a mutex that is being used in a <a href=
"../functions/pthread_cond_timedwait.html"><i>pthread_cond_timedwait</i>()</a> or <a href=
"../functions/pthread_cond_wait.html"><i>pthread_cond_wait</i>()</a> call by another thread, results in undefined behavior.</p>

<p>The <i>pthread_mutex_init</i>() function shall initialize the mutex referenced by <i>mutex</i> with attributes specified by
<i>attr</i>. If <i>attr</i> is NULL, the default mutex attributes are used; the effect shall be the same as passing the address of
a default mutex attributes object. Upon successful initialization, the state of the mutex becomes initialized and unlocked.</p>

<p>See <a href="../functions/V2_chap02.html#tag_15_09_09"><i>Synchronization Object Copies and Alternative Mappings</i></a> for
further requirements.</p>

<p>Attempting to initialize an already initialized mutex results in undefined behavior.</p>

<p>In cases where default mutex attributes are appropriate, the macro PTHREAD_MUTEX_INITIALIZER can be used to initialize mutexes.
The effect shall be equivalent to dynamic initialization by a call to <i>pthread_mutex_init</i>() with parameter <i>attr</i>
specified as NULL, except that no error checks are performed.</p>

<p>The behavior is undefined if the value specified by the <i>mutex</i> argument to <i>pthread_mutex_destroy</i>() does not refer
to an initialized mutex.</p>

<p>The behavior is undefined if the value specified by the <i>attr</i> argument to <i>pthread_mutex_init</i>() does not refer to an
initialized mutex attributes object.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_437_04"></a>RETURN VALUE</h4>

<blockquote>
<p>If successful, the <i>pthread_mutex_destroy</i>() and <i>pthread_mutex_init</i>() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_437_05"></a>ERRORS</h4>

<blockquote>
<p>The <i>pthread_mutex_init</i>() function shall fail if:</p>

<dl compact>
<dt>[EAGAIN]</dt>

<dd>The system lacked the necessary resources (other than memory) to initialize another mutex.</dd>

<dt>[ENOMEM]</dt>

<dd>Insufficient memory exists to initialize the mutex.</dd>

<dt>[EPERM]</dt>

<dd>The caller does not have the privilege to perform the operation.</dd>
</dl>

<br>
<p>The <i>pthread_mutex_init</i>() function may fail if:</p>

<dl compact>
<dt>[EINVAL]</dt>

<dd>The attributes object referenced by <i>attr</i> has the robust mutex attribute set without the process-shared attribute being
set.</dd>
</dl>

<p>These functions shall not return an error code of [EINTR].</p>
</blockquote>

<hr>
<div class="box"><em>The following sections are informative.</em></div>

<h4 class="mansect"><a name="tag_16_437_06"></a>EXAMPLES</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_437_07"></a>APPLICATION USAGE</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_437_08"></a>RATIONALE</h4>

<blockquote>
<p>If an implementation detects that the value specified by the <i>mutex</i> argument to <i>pthread_mutex_destroy</i>() does not
refer to an initialized mutex, it is recommended that the function should fail and report an [EINVAL] error.</p>

<p>If an implementation detects that the value specified by the <i>mutex</i> argument to <i>pthread_mutex_destroy</i>() or
<i>pthread_mutex_init</i>() refers to a locked mutex or a mutex that is referenced (for example, while being used in a <a href=
"../functions/pthread_cond_timedwait.html"><i>pthread_cond_timedwait</i>()</a> or <a href=
"../functions/pthread_cond_wait.html"><i>pthread_cond_wait</i>()</a>) by another thread, or detects that the value specified by the
<i>mutex</i> argument to <i>pthread_mutex_init</i>() refers to an already initialized mutex, it is recommended that the function
should fail and report an [EBUSY] error.</p>

<p>If an implementation detects that the value specified by the <i>attr</i> argument to <i>pthread_mutex_init</i>() does not refer
to an initialized mutex attributes object, it is recommended that the function should fail and report an [EINVAL] error.</p>

<h5><a name="tag_16_437_08_01"></a>Alternate Implementations Possible</h5>

<p>This volume of POSIX.1-2017 supports several alternative implementations of mutexes. An implementation may store the lock
directly in the object of type <b>pthread_mutex_t</b>. Alternatively, an implementation may store the lock in the heap and merely
store a pointer, handle, or unique ID in the mutex object. Either implementation has advantages or may be required on certain
hardware configurations. So that portable code can be written that is invariant to this choice, this volume of POSIX.1-2017 does
not define assignment or equality for this type, and it uses the term &quot;initialize&quot; to reinforce the (more restrictive) notion
that the lock may actually reside in the mutex object itself.</p>

<p>Note that this precludes an over-specification of the type of the mutex or condition variable and motivates the opaqueness of
the type.</p>

<p>An implementation is permitted, but not required, to have <i>pthread_mutex_destroy</i>() store an illegal value into the mutex.
This may help detect erroneous programs that try to lock (or otherwise reference) a mutex that has already been destroyed.</p>

<h5><a name="tag_16_437_08_02"></a>Tradeoff Between Error Checks and Performance Supported</h5>

<p>Many error conditions that can occur are not required to be detected by the implementation in order to let implementations trade
off performance <i>versus</i> degree of error checking according to the needs of their specific applications and execution
environment. As a general rule, conditions caused by the system (such as insufficient memory) are required to be detected, but
conditions caused by an erroneously coded application (such as failing to provide adequate synchronization to prevent a mutex from
being deleted while in use) are specified to result in undefined behavior.</p>

<p>A wide range of implementations is thus made possible. For example, an implementation intended for application debugging may
implement all of the error checks, but an implementation running a single, provably correct application under very tight
performance constraints in an embedded computer might implement minimal checks. An implementation might even be provided in two
versions, similar to the options that compilers provide: a full-checking, but slower version; and a limited-checking, but faster
version. To forbid this optionality would be a disservice to users.</p>

<p>By carefully limiting the use of &quot;undefined behavior&quot; only to things that an erroneous (badly coded) application might do, and
by defining that resource-not-available errors are mandatory, this volume of POSIX.1-2017 ensures that a fully-conforming
application is portable across the full range of implementations, while not forcing all implementations to add overhead to check
for numerous things that a correct program never does. When the behavior is undefined, no error number is specified to be returned
on implementations that do detect the condition. This is because undefined behavior means <i>anything</i> can happen, which
includes returning with any value (which might happen to be a valid, but different, error number). However, since the error number
might be useful to application developers when diagnosing problems during application development, a recommendation is made in
rationale that implementors should return a particular error number if their implementation does detect the condition.</p>

<h5><a name="tag_16_437_08_03"></a>Why No Limits are Defined</h5>

<p>Defining symbols for the maximum number of mutexes and condition variables was considered but rejected because the number of
these objects may change dynamically. Furthermore, many implementations place these objects into application memory; thus, there is
no explicit maximum.</p>

<h5><a name="tag_16_437_08_04"></a>Static Initializers for Mutexes and Condition Variables</h5>

<p>Providing for static initialization of statically allocated synchronization objects allows modules with private static
synchronization variables to avoid runtime initialization tests and overhead. Furthermore, it simplifies the coding of
self-initializing modules. Such modules are common in C libraries, where for various reasons the design calls for
self-initialization instead of requiring an explicit module initialization function to be called. An example use of static
initialization follows.</p>

<p>Without static initialization, a self-initializing routine <i>foo</i>() might look as follows:</p>

<pre>
<tt>static pthread_once_t foo_once = PTHREAD_ONCE_INIT;
static pthread_mutex_t foo_mutex;
<br>
void foo_init()
{
    pthread_mutex_init(&amp;foo_mutex, NULL);
}
<br>
void foo()
{
    pthread_once(&amp;foo_once, foo_init);
    pthread_mutex_lock(&amp;foo_mutex);
   /* Do work. */
    pthread_mutex_unlock(&amp;foo_mutex);
}
</tt>
</pre>

<p>With static initialization, the same routine could be coded as follows:</p>

<pre>
<tt>static pthread_mutex_t foo_mutex = PTHREAD_MUTEX_INITIALIZER;
<br>
void foo()
{
    pthread_mutex_lock(&amp;foo_mutex);
   /* Do work. */
    pthread_mutex_unlock(&amp;foo_mutex);
}
</tt>
</pre>

<p>Note that the static initialization both eliminates the need for the initialization test inside <a href=
"../functions/pthread_once.html"><i>pthread_once</i>()</a> and the fetch of &amp;<i>foo_mutex</i> to learn the address to be passed
to <a href="../functions/pthread_mutex_lock.html"><i>pthread_mutex_lock</i>()</a> or <a href=
"../functions/pthread_mutex_unlock.html"><i>pthread_mutex_unlock</i>()</a>.</p>

<p>Thus, the C code written to initialize static objects is simpler on all systems and is also faster on a large class of systems;
those where the (entire) synchronization object can be stored in application memory.</p>

<p>Yet the locking performance question is likely to be raised for machines that require mutexes to be allocated out of special
memory. Such machines actually have to have mutexes and possibly condition variables contain pointers to the actual hardware locks.
For static initialization to work on such machines, <a href="../functions/pthread_mutex_lock.html"><i>pthread_mutex_lock</i>()</a>
also has to test whether or not the pointer to the actual lock has been allocated. If it has not, <a href=
"../functions/pthread_mutex_lock.html"><i>pthread_mutex_lock</i>()</a> has to initialize it before use. The reservation of such
resources can be made when the program is loaded, and hence return codes have not been added to mutex locking and condition
variable waiting to indicate failure to complete initialization.</p>

<p>This runtime test in <a href="../functions/pthread_mutex_lock.html"><i>pthread_mutex_lock</i>()</a> would at first seem to be
extra work; an extra test is required to see whether the pointer has been initialized. On most machines this would actually be
implemented as a fetch of the pointer, testing the pointer against zero, and then using the pointer if it has already been
initialized. While the test might seem to add extra work, the extra effort of testing a register is usually negligible since no
extra memory references are actually done. As more and more machines provide caches, the real expenses are memory references, not
instructions executed.</p>

<p>Alternatively, depending on the machine architecture, there are often ways to eliminate <i>all</i> overhead in the most
important case: on the lock operations that occur <i>after</i> the lock has been initialized. This can be done by shifting more
overhead to the less frequent operation: initialization. Since out-of-line mutex allocation also means that an address has to be
dereferenced to find the actual lock, one technique that is widely applicable is to have static initialization store a bogus value
for that address; in particular, an address that causes a machine fault to occur. When such a fault occurs upon the first attempt
to lock such a mutex, validity checks can be done, and then the correct address for the actual lock can be filled in. Subsequent
lock operations incur no extra overhead since they do not &quot;fault&quot;. This is merely one technique that can be used to support
static initialization, while not adversely affecting the performance of lock acquisition. No doubt there are other techniques that
are highly machine-dependent.</p>

<p>The locking overhead for machines doing out-of-line mutex allocation is thus similar for modules being implicitly initialized,
where it is improved for those doing mutex allocation entirely inline. The inline case is thus made much faster, and the
out-of-line case is not significantly worse.</p>

<p>Besides the issue of locking performance for such machines, a concern is raised that it is possible that threads would serialize
contending for initialization locks when attempting to finish initializing statically allocated mutexes. (Such finishing would
typically involve taking an internal lock, allocating a structure, storing a pointer to the structure in the mutex, and releasing
the internal lock.) First, many implementations would reduce such serialization by hashing on the mutex address. Second, such
serialization can only occur a bounded number of times. In particular, it can happen at most as many times as there are statically
allocated synchronization objects. Dynamically allocated objects would still be initialized via <i>pthread_mutex_init</i>() or <a
href="../functions/pthread_cond_init.html"><i>pthread_cond_init</i>()</a>.</p>

<p>Finally, if none of the above optimization techniques for out-of-line allocation yields sufficient performance for an
application on some implementation, the application can avoid static initialization altogether by explicitly initializing all
synchronization objects with the corresponding <i>pthread_*_init</i>() functions, which are supported by all implementations. An
implementation can also document the tradeoffs and advise which initialization technique is more efficient for that particular
implementation.</p>

<h5><a name="tag_16_437_08_05"></a>Destroying Mutexes</h5>

<p>A mutex can be destroyed immediately after it is unlocked. However, since attempting to destroy a locked mutex, or a mutex that
another thread is attempting to lock, or a mutex that is being used in a <a href=
"../functions/pthread_cond_timedwait.html"><i>pthread_cond_timedwait</i>()</a> or <a href=
"../functions/pthread_cond_wait.html"><i>pthread_cond_wait</i>()</a> call by another thread, results in undefined behavior, care
must be taken to ensure that no other thread may be referencing the mutex.</p>

<h5><a name="tag_16_437_08_06"></a>Robust Mutexes</h5>

<p>Implementations are required to provide robust mutexes for mutexes with the process-shared attribute set to
PTHREAD_PROCESS_SHARED. Implementations are allowed, but not required, to provide robust mutexes when the process-shared attribute
is set to PTHREAD_PROCESS_PRIVATE.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_437_09"></a>FUTURE DIRECTIONS</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_437_10"></a>SEE ALSO</h4>

<blockquote>
<p><a href="../functions/pthread_mutex_getprioceiling.html#"><i>pthread_mutex_getprioceiling</i></a>, <a href=
"../functions/pthread_mutexattr_getrobust.html#"><i>pthread_mutexattr_getrobust</i></a>, <a href=
"../functions/pthread_mutex_lock.html#"><i>pthread_mutex_lock</i></a>, <a href=
"../functions/pthread_mutex_timedlock.html#"><i>pthread_mutex_timedlock</i></a>, <a href=
"../functions/pthread_mutexattr_getpshared.html#"><i>pthread_mutexattr_getpshared</i></a></p>

<p>XBD <a href="../basedefs/pthread.h.html"><i>&lt;pthread.h&gt;</i></a></p>
</blockquote>

<h4 class="mansect"><a name="tag_16_437_11"></a>CHANGE HISTORY</h4>

<blockquote>
<p>First released in Issue 5. Included for alignment with the POSIX Threads Extension.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_437_12"></a>Issue 6</h4>

<blockquote>
<p>The <i>pthread_mutex_destroy</i>() and <i>pthread_mutex_init</i>() functions are marked as part of the Threads option.</p>

<p>The <a href="../functions/pthread_mutex_timedlock.html"><i>pthread_mutex_timedlock</i>()</a> function is added to the SEE ALSO
section for alignment with IEEE&nbsp;Std&nbsp;1003.1d-1999.</p>

<p>IEEE PASC Interpretation 1003.1c #34 is applied, updating the DESCRIPTION.</p>

<p>The <b>restrict</b> keyword is added to the <i>pthread_mutex_init</i>() prototype for alignment with the ISO/IEC&nbsp;9899:1999
standard.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_437_13"></a>Issue 7</h4>

<blockquote>
<p>Changes are made from The Open Group Technical Standard, 2006, Extended API Set Part 3.</p>

<p>The <i>pthread_mutex_destroy</i>() and <i>pthread_mutex_init</i>() functions are moved from the Threads option to the Base.</p>

<p>The [EINVAL] error for an uninitialized mutex or an uninitialized mutex attributes object is removed; this condition results in
undefined behavior.</p>

<p>The [EBUSY] error for a locked mutex, a mutex that is referenced, or an already initialized mutex is removed; this condition
results in undefined behavior.</p>

<p>POSIX.1-2008, Technical Corrigendum 1, XSH/TC1-2008/0460 [70,428] is applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0278 [811], XSH/TC2-2008/0279 [972], and XSH/TC2-2008/0280 [811] are
applied.</p>
</blockquote>

<div class="box"><em>End of informative text.</em></div>

<hr>
<p>&nbsp;</p>

<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
Copyright &copy; 2001-2018 IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/pthread_mutex_consistent.html" accesskey=
"P">&lt;&lt;&lt; Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/pthread_mutex_getprioceiling.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>
</body>
</html>

