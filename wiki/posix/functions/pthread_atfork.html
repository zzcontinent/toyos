<!-- Copyright 2001-2013 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group's rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2013 The Open Group, All Rights Reserved -->
<title>pthread_atfork</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/psiginfo.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/pthread_attr_destroy.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>


<basefont size="3"> 

<center><font size="2">The Open Group Base Specifications Issue 7, 2018 edition<br>
IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)<br>
Copyright &copy; 2001-2018 IEEE and The Open Group</font></center>

<hr size="2" noshade>
<a name="top"></a> <a name="pthread_atfork"></a> <a name="tag_16_402"></a><!-- pthread_atfork -->
 

<h4 class="mansect"><a name="tag_16_402_01"></a>NAME</h4>

<blockquote>pthread_atfork - register fork handlers</blockquote>

<h4 class="mansect"><a name="tag_16_402_02"></a>SYNOPSIS</h4>

<blockquote class="synopsis">
<p><code><tt>#include &lt;<a href="../basedefs/pthread.h.html">pthread.h</a>&gt;<br>
<br>
 int pthread_atfork(void (*</tt><i>prepare</i><tt>)(void), void (*</tt><i>parent</i><tt>)(void),<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*</tt><i>child</i><tt>)(void));<br>
</tt></code></p>
</blockquote>

<h4 class="mansect"><a name="tag_16_402_03"></a>DESCRIPTION</h4>

<blockquote>
<p>The <i>pthread_atfork</i>() function shall declare fork handlers to be called before and after <a href=
"../functions/fork.html"><i>fork</i>()</a>, in the context of the thread that called <a href=
"../functions/fork.html"><i>fork</i>()</a>. The <i>prepare</i> fork handler shall be called before <a href=
"../functions/fork.html"><i>fork</i>()</a> processing commences. The <i>parent</i> fork handle shall be called after <a href=
"../functions/fork.html"><i>fork</i>()</a> processing completes in the parent process. The <i>child</i> fork handler shall be
called after <a href="../functions/fork.html"><i>fork</i>()</a> processing completes in the child process. If no handling is
desired at one or more of these three points, the corresponding fork handler address(es) may be set to NULL.</p>

<p>If a <a href="../functions/fork.html"><i>fork</i>()</a> call in a multi-threaded process leads to a <i>child</i> fork handler
calling any function that is not async-signal-safe, the behavior is undefined.</p>

<p>The order of calls to <i>pthread_atfork</i>() is significant. The <i>parent</i> and <i>child</i> fork handlers shall be called
in the order in which they were established by calls to <i>pthread_atfork</i>(). The <i>prepare</i> fork handlers shall be called
in the opposite order.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_402_04"></a>RETURN VALUE</h4>

<blockquote>
<p>Upon successful completion, <i>pthread_atfork</i>() shall return a value of zero; otherwise, an error number shall be returned
to indicate the error.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_402_05"></a>ERRORS</h4>

<blockquote>
<p>The <i>pthread_atfork</i>() function shall fail if:</p>

<dl compact>
<dt>[ENOMEM]</dt>

<dd>Insufficient table space exists to record the fork handler addresses.</dd>
</dl>

<p>The <i>pthread_atfork</i>() function shall not return an error code of [EINTR].</p>
</blockquote>

<hr>
<div class="box"><em>The following sections are informative.</em></div>

<h4 class="mansect"><a name="tag_16_402_06"></a>EXAMPLES</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_402_07"></a>APPLICATION USAGE</h4>

<blockquote>
<p>The original usage pattern envisaged for <i>pthread_atfork</i>() was for the <i>prepare</i> fork handler to lock mutexes and
other locks, and for the <i>parent</i> and <i>child</i> handlers to unlock them. However, since all of the relevant unlocking
functions, except <a href="../functions/sem_post.html"><i>sem_post</i>()</a>, are not async-signal-safe, this usage results in
undefined behavior in the child process unless the only such unlocking function it calls is <a href=
"../functions/sem_post.html"><i>sem_post</i>()</a>.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_402_08"></a>RATIONALE</h4>

<blockquote>
<p>There are at least two serious problems with the semantics of <a href="../functions/fork.html"><i>fork</i>()</a> in a
multi-threaded program. One problem has to do with state (for example, memory) covered by mutexes. Consider the case where one
thread has a mutex locked and the state covered by that mutex is inconsistent while another thread calls <a href=
"../functions/fork.html"><i>fork</i>()</a>. In the child, the mutex is in the locked state (locked by a nonexistent thread and thus
can never be unlocked). Having the child simply reinitialize the mutex is unsatisfactory since this approach does not resolve the
question about how to correct or otherwise deal with the inconsistent state in the child.</p>

<p>It is suggested that programs that use <a href="../functions/fork.html"><i>fork</i>()</a> call an <i><a href=
"../functions/exec.html">exec</a></i> function very soon afterwards in the child process, thus resetting all states. In the
meantime, only a short list of async-signal-safe library routines are promised to be available.</p>

<p>Unfortunately, this solution does not address the needs of multi-threaded libraries. Application programs may not be aware that
a multi-threaded library is in use, and they feel free to call any number of library routines between the <a href=
"../functions/fork.html"><i>fork</i>()</a> and <i><a href="../functions/exec.html">exec</a></i> calls, just as they always have.
Indeed, they may be extant single-threaded programs and cannot, therefore, be expected to obey new restrictions imposed by the
threads library.</p>

<p>On the other hand, the multi-threaded library needs a way to protect its internal state during <a href=
"../functions/fork.html"><i>fork</i>()</a> in case it is re-entered later in the child process. The problem arises especially in
multi-threaded I/O libraries, which are almost sure to be invoked between the <a href="../functions/fork.html"><i>fork</i>()</a>
and <i><a href="../functions/exec.html">exec</a></i> calls to effect I/O redirection. The solution may require locking mutex
variables during <a href="../functions/fork.html"><i>fork</i>()</a>, or it may entail simply resetting the state in the child after
the <a href="../functions/fork.html"><i>fork</i>()</a> processing completes.</p>

<p>The <i>pthread_atfork</i>() function was intended to provide multi-threaded libraries with a means to protect themselves from
innocent application programs that call <a href="../functions/fork.html"><i>fork</i>()</a>, and to provide multi-threaded
application programs with a standard mechanism for protecting themselves from <a href="../functions/fork.html"><i>fork</i>()</a>
calls in a library routine or the application itself.</p>

<p>The expected usage was that the prepare handler would acquire all mutex locks and the other two fork handlers would release
them.</p>

<p>For example, an application could have supplied a prepare routine that acquires the necessary mutexes the library maintains and
supplied child and parent routines that release those mutexes, thus ensuring that the child would have got a consistent snapshot of
the state of the library (and that no mutexes would have been left stranded). This is good in theory, but in reality not practical.
Each and every mutex and lock in the process must be located and locked. Every component of a program including third-party
components must participate and they must agree who is responsible for which mutex or lock. This is especially problematic for
mutexes and locks in dynamically allocated memory. All mutexes and locks internal to the implementation must be locked, too. This
possibly delays the thread calling <a href="../functions/fork.html"><i>fork</i>()</a> for a long time or even indefinitely since
uses of these synchronization objects may not be under control of the application. A final problem to mention here is the problem
of locking streams. At least the streams under control of the system (like <i>stdin</i>, <i>stdout</i>, <i>stderr</i>) must be
protected by locking the stream with <a href="../functions/flockfile.html"><i>flockfile</i>()</a>. But the application itself could
have done that, possibly in the same thread calling <a href="../functions/fork.html"><i>fork</i>()</a>. In this case, the process
will deadlock.</p>

<p>Alternatively, some libraries might have been able to supply just a <i>child</i> routine that reinitializes the mutexes in the
library and all associated states to some known value (for example, what it was when the image was originally executed). This
approach is not possible, though, because implementations are allowed to fail <i>*_init</i>() and <i>*_destroy</i>() calls for
mutexes and locks if the mutex or lock is still locked. In this case, the <i>child</i> routine is not able to reinitialize the
mutexes and locks.</p>

<p>When <a href="../functions/fork.html"><i>fork</i>()</a> is called, only the calling thread is duplicated in the child process.
Synchronization variables remain in the same state in the child as they were in the parent at the time <a href=
"../functions/fork.html"><i>fork</i>()</a> was called. Thus, for example, mutex locks may be held by threads that no longer exist
in the child process, and any associated states may be inconsistent. The intention was that the parent process could have avoided
this by explicit code that acquires and releases locks critical to the child via <i>pthread_atfork</i>(). In addition, any critical
threads would have needed to be recreated and reinitialized to the proper state in the child (also via
<i>pthread_atfork</i>()).</p>

<p>A higher-level package may acquire locks on its own data structures before invoking lower-level packages. Under this scenario,
the order specified for fork handler calls allows a simple rule of initialization for avoiding package deadlock: a package
initializes all packages on which it depends before it calls the <i>pthread_atfork</i>() function for itself.</p>

<p>As explained, there is no suitable solution for functionality which requires non-atomic operations to be protected through
mutexes and locks. This is why the POSIX.1 standard since the 1996 release requires that the child process after <a href=
"../functions/fork.html"><i>fork</i>()</a> in a multi-threaded process only calls async-signal-safe interfaces.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_402_09"></a>FUTURE DIRECTIONS</h4>

<blockquote>
<p>The <i>pthread_atfork</i>() function may be formally deprecated (for example, by shading it OB) in a future version of this
standard.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_402_10"></a>SEE ALSO</h4>

<blockquote>
<p><a href="../functions/atexit.html#"><i>atexit</i></a>, <a href="../functions/exec.html#tag_16_111"><i><a href=
"../functions/exec.html">exec</a></i></a>, <a href="../functions/fork.html#"><i>fork</i></a></p>

<p>XBD <a href="../basedefs/pthread.h.html"><i>&lt;pthread.h&gt;</i></a>, <a href=
"../basedefs/sys_types.h.html"><i>&lt;sys/types.h&gt;</i></a></p>
</blockquote>

<h4 class="mansect"><a name="tag_16_402_11"></a>CHANGE HISTORY</h4>

<blockquote>
<p>First released in Issue 5. Derived from the POSIX Threads Extension.</p>

<p>IEEE PASC Interpretation 1003.1c #4 is applied.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_402_12"></a>Issue 6</h4>

<blockquote>
<p>The <i>pthread_atfork</i>() function is marked as part of the Threads option.</p>

<p>The <a href="../basedefs/pthread.h.html"><i>&lt;pthread.h&gt;</i></a> header is added to the SYNOPSIS.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_402_13"></a>Issue 7</h4>

<blockquote>
<p>The <i>pthread_atfork</i>() function is moved from the Threads option to the Base.</p>

<p>SD5-XSH-ERN-145 is applied, updating the RATIONALE.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XSH/TC2-2008/0261 [858] is applied.</p>
</blockquote>

<div class="box"><em>End of informative text.</em></div>

<hr>
<p>&nbsp;</p>

<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
Copyright &copy; 2001-2018 IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/psiginfo.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/pthread_attr_destroy.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>
</body>
</html>

