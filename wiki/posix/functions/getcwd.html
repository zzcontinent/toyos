<!-- Copyright 2001-2013 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group's rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2013 The Open Group, All Rights Reserved -->
<title>getcwd</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/getchar.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/getdate.html" accesskey="N">Next &gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>


<basefont size="3"> 

<center><font size="2">The Open Group Base Specifications Issue 7, 2018 edition<br>
IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)<br>
Copyright &copy; 2001-2018 IEEE and The Open Group</font></center>

<hr size="2" noshade>
<a name="top"></a> <a name="getcwd"></a> <a name="tag_16_190"></a><!-- getcwd -->
 

<h4 class="mansect"><a name="tag_16_190_01"></a>NAME</h4>

<blockquote>getcwd - get the pathname of the current working directory</blockquote>

<h4 class="mansect"><a name="tag_16_190_02"></a>SYNOPSIS</h4>

<blockquote class="synopsis">
<p><code><tt>#include &lt;<a href="../basedefs/unistd.h.html">unistd.h</a>&gt;<br>
<br>
 char *getcwd(char *</tt><i>buf</i><tt>, size_t</tt> <i>size</i><tt>);<br>
</tt></code></p>
</blockquote>

<h4 class="mansect"><a name="tag_16_190_03"></a>DESCRIPTION</h4>

<blockquote>
<p>The <i>getcwd</i>() function shall place an absolute pathname of the current working directory in the array pointed to by
<i>buf</i>, and return <i>buf</i>. The pathname shall contain no components that are dot or dot-dot, or are symbolic links.</p>

<p>If there are multiple pathnames that <i>getcwd</i>() could place in the array pointed to by <i>buf</i>, one beginning with a
single &lt;slash&gt; character and one or more beginning with two &lt;slash&gt; characters, then <i>getcwd</i>() shall place the
pathname beginning with a single &lt;slash&gt; character in the array. The pathname shall not contain any unnecessary &lt;slash&gt;
characters after the leading one or two &lt;slash&gt; characters.</p>

<p>The <i>size</i> argument is the size in bytes of the character array pointed to by the <i>buf</i> argument. If <i>buf</i> is a
null pointer, the behavior of <i>getcwd</i>() is unspecified.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_190_04"></a>RETURN VALUE</h4>

<blockquote>
<p>Upon successful completion, <i>getcwd</i>() shall return the <i>buf</i> argument. Otherwise, <i>getcwd</i>() shall return a null
pointer and set <i>errno</i> to indicate the error. The contents of the array pointed to by <i>buf</i> are then undefined.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_190_05"></a>ERRORS</h4>

<blockquote>
<p>The <i>getcwd</i>() function shall fail if:</p>

<dl compact>
<dt>[EINVAL]</dt>

<dd>The <i>size</i> argument is 0.</dd>

<dt>[ERANGE]</dt>

<dd>The <i>size</i> argument is greater than 0, but is smaller than the length of the string +1.</dd>
</dl>

<p>The <i>getcwd</i>() function may fail if:</p>

<dl compact>
<dt>[EACCES]</dt>

<dd>Search permission was denied for the current directory, or read or search permission was denied for a directory above the
current directory in the file hierarchy.</dd>

<dt>[ENOMEM]</dt>

<dd>Insufficient storage space is available.</dd>
</dl>
</blockquote>

<hr>
<div class="box"><em>The following sections are informative.</em></div>

<h4 class="mansect"><a name="tag_16_190_06"></a>EXAMPLES</h4>

<blockquote>
<p>The following example uses {PATH_MAX} as the initial buffer size (unless it is indeterminate or very large), and calls
<i>getcwd</i>() with progressively larger buffers until it does not give an [ERANGE] error.</p>

<pre>
<tt>#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
<br>
...
<br>
long path_max;
size_t size;
char *buf;
char *ptr;
<br>
path_max = pathconf(".", _PC_PATH_MAX);
if (path_max == -1)
    size = 1024;
else if (path_max &gt; 10240)
    size = 10240;
else
    size = path_max;
<br>
for (buf = ptr = NULL; ptr == NULL; size *= 2)
{
    if ((buf = realloc(buf, size)) == NULL)
    {
        ... handle error ...
    }
<br>
    ptr = getcwd(buf, size);
    if (ptr == NULL &amp;&amp; errno != ERANGE)
    {
        ... handle error ...
    }
}
...
free (buf);
</tt>
</pre>
</blockquote>

<h4 class="mansect"><a name="tag_16_190_07"></a>APPLICATION USAGE</h4>

<blockquote>
<p>If the pathname obtained from <i>getcwd</i>() is longer than {PATH_MAX} bytes, it could produce an [ENAMETOOLONG] error if
passed to <a href="../functions/chdir.html"><i>chdir</i>()</a>. Therefore, in order to return to that directory it may be necessary
to break the pathname into sections shorter than {PATH_MAX} bytes and call <a href="../functions/chdir.html"><i>chdir</i>()</a> on
each section in turn (the first section being an absolute pathname and subsequent sections being relative pathnames). A simpler way
to handle saving and restoring the working directory when it may be deeper than {PATH_MAX} bytes in the file hierarchy is to use a
file descriptor and <a href="../functions/fchdir.html"><i>fchdir</i>()</a>, rather than <i>getcwd</i>() and <a href=
"../functions/chdir.html"><i>chdir</i>()</a>. However, the two methods do have some differences. The <a href=
"../functions/fchdir.html"><i>fchdir</i>()</a> approach causes the program to restore a working directory even if it has been
renamed in the meantime, whereas the <a href="../functions/chdir.html"><i>chdir</i>()</a> approach restores to a directory with the
same name as the original, even if the directories were renamed in the meantime. Since the <a href=
"../functions/fchdir.html"><i>fchdir</i>()</a> approach does not access parent directories, it can succeed when <i>getcwd</i>()
would fail due to permissions problems. In applications conforming to earlier versions of this standard, it was not possible to use
the <a href="../functions/fchdir.html"><i>fchdir</i>()</a> approach when the working directory is searchable but not readable, as
the only way to open a directory was with O_RDONLY, whereas the <i>getcwd</i>() approach can succeed in this case.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_190_08"></a>RATIONALE</h4>

<blockquote>
<p>Having <i>getcwd</i>() take no arguments and instead use the <a href="../functions/malloc.html"><i>malloc</i>()</a> function to
produce space for the returned argument was considered. The advantage is that <i>getcwd</i>() knows how big the working directory
pathname is and can allocate an appropriate amount of space. But the programmer would have to use the <a href=
"../functions/free.html"><i>free</i>()</a> function to free the resulting object, or each use of <i>getcwd</i>() would further
reduce the available memory. Finally, <i>getcwd</i>() is taken from the SVID where it has the two arguments used in this volume of
POSIX.1-2017.</p>

<p>The older function <i>getwd</i>() was rejected for use in this context because it had only a buffer argument and no <i>size</i>
argument, and thus had no way to prevent overwriting the buffer, except to depend on the programmer to provide a large enough
buffer.</p>

<p>On some implementations, if <i>buf</i> is a null pointer, <i>getcwd</i>() may obtain <i>size</i> bytes of memory using <a href=
"../functions/malloc.html"><i>malloc</i>()</a>. In this case, the pointer returned by <i>getcwd</i>() may be used as the argument
in a subsequent call to <a href="../functions/free.html"><i>free</i>()</a>. Invoking <i>getcwd</i>() with <i>buf</i> as a null
pointer is not recommended in conforming applications.</p>

<p>Earlier implementations of <i>getcwd</i>() sometimes generated pathnames like <tt>"../../../subdirname"</tt> internally, using
them to explore the path of ancestor directories back to the root. If one of these internal pathnames exceeded {PATH_MAX} in
length, the implementation could fail with <i>errno</i> set to [ENAMETOOLONG]. This is no longer allowed.</p>

<p>If a program is operating in a directory where some (grand)parent directory does not permit reading, <i>getcwd</i>() may fail,
as in most implementations it must read the directory to determine the name of the file. This can occur if search, but not read,
permission is granted in an intermediate directory, or if the program is placed in that directory by some more privileged process
(for example, login). Including the [EACCES] error condition makes the reporting of the error consistent and warns the application
developer that <i>getcwd</i>() can fail for reasons beyond the control of the application developer or user. Some implementations
can avoid this occurrence (for example, by implementing <i>getcwd</i>() using <a href="../utilities/pwd.html"><i>pwd</i></a>, where
<a href="../utilities/pwd.html"><i>pwd</i></a> is a set-user-root process), thus the error was made optional. Since this volume of
POSIX.1-2017 permits the addition of other errors, this would be a common addition and yet one that applications could not be
expected to deal with without this addition.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_190_09"></a>FUTURE DIRECTIONS</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_190_10"></a>SEE ALSO</h4>

<blockquote>
<p><a href="../functions/malloc.html#"><i>malloc</i></a></p>

<p>XBD <a href="../basedefs/unistd.h.html"><i>&lt;unistd.h&gt;</i></a></p>
</blockquote>

<h4 class="mansect"><a name="tag_16_190_11"></a>CHANGE HISTORY</h4>

<blockquote>
<p>First released in Issue 1. Derived from Issue 1 of the SVID.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_190_12"></a>Issue 6</h4>

<blockquote>
<p>The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:</p>

<ul>
<li>
<p>The [ENOMEM] optional error condition is added.</p>
</li>
</ul>
</blockquote>

<h4 class="mansect"><a name="tag_16_190_13"></a>Issue 7</h4>

<blockquote>
<p>Austin Group Interpretation 1003.1-2001 #140 is applied, changing the text for consistency with the <a href=
"../utilities/pwd.html"><i>pwd</i></a> utility, adding text to address the case where the current directory is deeper in the file
hierarchy than {PATH_MAX} bytes, and adding the requirements relating to pathnames beginning with two &lt;slash&gt; characters.</p>
</blockquote>

<div class="box"><em>End of informative text.</em></div>

<hr>
<p>&nbsp;</p>

<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
Copyright &copy; 2001-2018 IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/getchar.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/getdate.html" accesskey="N">Next &gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>
</body>
</html>

