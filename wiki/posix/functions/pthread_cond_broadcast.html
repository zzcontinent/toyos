<!-- Copyright 2001-2013 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group's rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2013 The Open Group, All Rights Reserved -->
<title>pthread_cond_broadcast</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/pthread_cleanup_pop.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/pthread_cond_destroy.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>


<basefont size="3"> 

<center><font size="2">The Open Group Base Specifications Issue 7, 2018 edition<br>
IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)<br>
Copyright &copy; 2001-2018 IEEE and The Open Group</font></center>

<hr size="2" noshade>
<a name="top"></a> <a name="pthread_cond_broadcast"></a> <a name="tag_16_418"></a><!-- pthread_cond_broadcast -->
 

<h4 class="mansect"><a name="tag_16_418_01"></a>NAME</h4>

<blockquote>pthread_cond_broadcast, pthread_cond_signal - broadcast or signal a condition</blockquote>

<h4 class="mansect"><a name="tag_16_418_02"></a>SYNOPSIS</h4>

<blockquote class="synopsis">
<p><code><tt>#include &lt;<a href="../basedefs/pthread.h.html">pthread.h</a>&gt;<br>
<br>
 int pthread_cond_broadcast(pthread_cond_t *</tt><i>cond</i><tt>);<br>
 int pthread_cond_signal(pthread_cond_t *</tt><i>cond</i><tt>);<br>
</tt></code></p>
</blockquote>

<h4 class="mansect"><a name="tag_16_418_03"></a>DESCRIPTION</h4>

<blockquote>
<p>These functions shall unblock threads blocked on a condition variable.</p>

<p>The <i>pthread_cond_broadcast</i>() function shall unblock all threads currently blocked on the specified condition variable
<i>cond</i>.</p>

<p>The <i>pthread_cond_signal</i>() function shall unblock at least one of the threads that are blocked on the specified condition
variable <i>cond</i> (if any threads are blocked on <i>cond</i>).</p>

<p>If more than one thread is blocked on a condition variable, the scheduling policy shall determine the order in which threads are
unblocked. When each thread unblocked as a result of a <i>pthread_cond_broadcast</i>() or <i>pthread_cond_signal</i>() returns from
its call to <a href="../functions/pthread_cond_wait.html"><i>pthread_cond_wait</i>()</a> or <a href=
"../functions/pthread_cond_timedwait.html"><i>pthread_cond_timedwait</i>()</a>, the thread shall own the mutex with which it called
<a href="../functions/pthread_cond_wait.html"><i>pthread_cond_wait</i>()</a> or <a href=
"../functions/pthread_cond_timedwait.html"><i>pthread_cond_timedwait</i>()</a>. The thread(s) that are unblocked shall contend for
the mutex according to the scheduling policy (if applicable), and as if each had called <a href=
"../functions/pthread_mutex_lock.html"><i>pthread_mutex_lock</i>()</a>.</p>

<p>The <i>pthread_cond_broadcast</i>() or <i>pthread_cond_signal</i>() functions may be called by a thread whether or not it
currently owns the mutex that threads calling <a href="../functions/pthread_cond_wait.html"><i>pthread_cond_wait</i>()</a> or <a
href="../functions/pthread_cond_timedwait.html"><i>pthread_cond_timedwait</i>()</a> have associated with the condition variable
during their waits; however, if predictable scheduling behavior is required, then that mutex shall be locked by the thread calling
<i>pthread_cond_broadcast</i>() or <i>pthread_cond_signal</i>().</p>

<p>The <i>pthread_cond_broadcast</i>() and <i>pthread_cond_signal</i>() functions shall have no effect if there are no threads
currently blocked on <i>cond</i>.</p>

<p>The behavior is undefined if the value specified by the <i>cond</i> argument to <i>pthread_cond_broadcast</i>() or
<i>pthread_cond_signal</i>() does not refer to an initialized condition variable.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_418_04"></a>RETURN VALUE</h4>

<blockquote>
<p>If successful, the <i>pthread_cond_broadcast</i>() and <i>pthread_cond_signal</i>() functions shall return zero; otherwise, an
error number shall be returned to indicate the error.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_418_05"></a>ERRORS</h4>

<blockquote>
<p>These functions shall not return an error code of [EINTR].</p>
</blockquote>

<hr>
<div class="box"><em>The following sections are informative.</em></div>

<h4 class="mansect"><a name="tag_16_418_06"></a>EXAMPLES</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_418_07"></a>APPLICATION USAGE</h4>

<blockquote>
<p>The <i>pthread_cond_broadcast</i>() function is used whenever the shared-variable state has been changed in a way that more than
one thread can proceed with its task. Consider a single producer/multiple consumer problem, where the producer can insert multiple
items on a list that is accessed one item at a time by the consumers. By calling the <i>pthread_cond_broadcast</i>() function, the
producer would notify all consumers that might be waiting, and thereby the application would receive more throughput on a
multi-processor. In addition, <i>pthread_cond_broadcast</i>() makes it easier to implement a read-write lock. The
<i>pthread_cond_broadcast</i>() function is needed in order to wake up all waiting readers when a writer releases its lock.
Finally, the two-phase commit algorithm can use this broadcast function to notify all clients of an impending transaction
commit.</p>

<p>It is not safe to use the <i>pthread_cond_signal</i>() function in a signal handler that is invoked asynchronously. Even if it
were safe, there would still be a race between the test of the Boolean <a href=
"../functions/pthread_cond_wait.html"><i>pthread_cond_wait</i>()</a> that could not be efficiently eliminated.</p>

<p>Mutexes and condition variables are thus not suitable for releasing a waiting thread by signaling from code running in a signal
handler.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_418_08"></a>RATIONALE</h4>

<blockquote>
<p>If an implementation detects that the value specified by the <i>cond</i> argument to <i>pthread_cond_broadcast</i>() or
<i>pthread_cond_signal</i>() does not refer to an initialized condition variable, it is recommended that the function should fail
and report an [EINVAL] error.</p>

<h5><a name="tag_16_418_08_01"></a>Multiple Awakenings by Condition Signal</h5>

<p>On a multi-processor, it may be impossible for an implementation of <i>pthread_cond_signal</i>() to avoid the unblocking of more
than one thread blocked on a condition variable. For example, consider the following partial implementation of <a href=
"../functions/pthread_cond_wait.html"><i>pthread_cond_wait</i>()</a> and <i>pthread_cond_signal</i>(), executed by two threads in
the order given. One thread is trying to wait on the condition variable, another is concurrently executing
<i>pthread_cond_signal</i>(), while a third thread is already waiting.</p>

<pre>
<tt>pthread_cond_wait(mutex, cond):
    value = cond-&gt;value; /* 1 */
    pthread_mutex_unlock(mutex); /* 2 */
    pthread_mutex_lock(cond-&gt;mutex); /* 10 */
    if (value == cond-&gt;value) { /* 11 */
        me-&gt;next_cond = cond-&gt;waiter;
        cond-&gt;waiter = me;
        pthread_mutex_unlock(cond-&gt;mutex);
        unable_to_run(me);
    } else
        pthread_mutex_unlock(cond-&gt;mutex); /* 12 */
    pthread_mutex_lock(mutex); /* 13 */
<br>
pthread_cond_signal(cond):
    pthread_mutex_lock(cond-&gt;mutex); /* 3 */
    cond-&gt;value++; /* 4 */
    if (cond-&gt;waiter) { /* 5 */
        sleeper = cond-&gt;waiter; /* 6 */
        cond-&gt;waiter = sleeper-&gt;next_cond; /* 7 */
        able_to_run(sleeper); /* 8 */
    }
    pthread_mutex_unlock(cond-&gt;mutex); /* 9 */
</tt>
</pre>

<p>The effect is that more than one thread can return from its call to <a href=
"../functions/pthread_cond_wait.html"><i>pthread_cond_wait</i>()</a> or <a href=
"../functions/pthread_cond_timedwait.html"><i>pthread_cond_timedwait</i>()</a> as a result of one call to
<i>pthread_cond_signal</i>(). This effect is called &quot;spurious wakeup&quot;. Note that the situation is self-correcting in that the
number of threads that are so awakened is finite; for example, the next thread to call <a href=
"../functions/pthread_cond_wait.html"><i>pthread_cond_wait</i>()</a> after the sequence of events above blocks.</p>

<p>While this problem could be resolved, the loss of efficiency for a fringe condition that occurs only rarely is unacceptable,
especially given that one has to check the predicate associated with a condition variable anyway. Correcting this problem would
unnecessarily reduce the degree of concurrency in this basic building block for all higher-level synchronization operations.</p>

<p>An added benefit of allowing spurious wakeups is that applications are forced to code a predicate-testing-loop around the
condition wait. This also makes the application tolerate superfluous condition broadcasts or signals on the same condition variable
that may be coded in some other part of the application. The resulting applications are thus more robust. Therefore, POSIX.1-2017
explicitly documents that spurious wakeups may occur.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_418_09"></a>FUTURE DIRECTIONS</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_418_10"></a>SEE ALSO</h4>

<blockquote>
<p><a href="../functions/pthread_cond_destroy.html#"><i>pthread_cond_destroy</i></a>, <a href=
"../functions/pthread_cond_timedwait.html#"><i>pthread_cond_timedwait</i></a></p>

<p>XBD <a href="../basedefs/V1_chap04.html#tag_04_12"><i>Memory Synchronization</i></a>, <a href=
"../basedefs/pthread.h.html"><i>&lt;pthread.h&gt;</i></a></p>
</blockquote>

<h4 class="mansect"><a name="tag_16_418_11"></a>CHANGE HISTORY</h4>

<blockquote>
<p>First released in Issue 5. Included for alignment with the POSIX Threads Extension.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_418_12"></a>Issue 6</h4>

<blockquote>
<p>The <i>pthread_cond_broadcast</i>() and <i>pthread_cond_signal</i>() functions are marked as part of the Threads option.</p>

<p>The APPLICATION USAGE section is added.</p>
</blockquote>

<h4 class="mansect"><a name="tag_16_418_13"></a>Issue 7</h4>

<blockquote>
<p>The <i>pthread_cond_broadcast</i>() and <i>pthread_cond_signal</i>() functions are moved from the Threads option to the
Base.</p>

<p>The [EINVAL] error for an uninitialized condition variable is removed; this condition results in undefined behavior.</p>
</blockquote>

<div class="box"><em>End of informative text.</em></div>

<hr>
<p>&nbsp;</p>

<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
Copyright &copy; 2001-2018 IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../functions/pthread_cleanup_pop.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../functions/pthread_cond_destroy.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>
</body>
</html>

