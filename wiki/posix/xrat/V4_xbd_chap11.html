<!-- Copyright 2001-2013 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group's rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2013 The Open Group, All Rights Reserved -->
<title>General Terminal Interface</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../xrat/V4_xbd_chap10.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../xrat/V4_xbd_chap12.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>


<basefont size="3"> 

<center><font size="2">The Open Group Base Specifications Issue 7, 2018 edition<br>
IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)<br>
Copyright &copy; 2001-2018 IEEE and The Open Group</font></center>

<hr size="2" noshade>
<a name="top"></a> 

<h3><a name="tag_21_11">   A.11  </a>General Terminal Interface</h3>

<p>If the implementation does not support this interface on any device types, it should behave as if it were being used on a device
that is not a terminal device (in most cases <i>errno</i> will be set to [ENOTTY] on return from functions defined by this
interface). This is based on the fact that many applications are written to run both interactively and in some non-interactive
mode, and they adapt themselves at runtime. Requiring that they all be modified to test an environment variable to determine
whether they should try to adapt is unnecessary. On a system that provides no general terminal interface, providing all the entry
points as stubs that return [ENOTTY] (or an equivalent, as appropriate) has the same effect and requires no changes to the
application.</p>

<p>Although the needs of both interface implementors and application developers were addressed throughout POSIX.1-2017, this
section pays more attention to the needs of the latter. This is because, while many aspects of the programming interface can be
hidden from the user by the application developer, the terminal interface is usually a large part of the user interface. Although
to some extent the application developer can build missing features or work around inappropriate ones, the difficulties of doing
that are greater in the terminal interface than elsewhere. For example, efficiency prohibits the average program from interpreting
every character passing through it in order to simulate character erase, line kill, and so on. These functions should usually be
done by the operating system, possibly at the interrupt level.</p>

<p>The <a href="../functions/tc*.html"><i>tc*</i>()</a> functions were introduced as a way of avoiding the problems inherent in the
traditional <a href="../functions/ioctl.html"><i>ioctl</i>()</a> function and in variants of it that were proposed. For example, <a
href="../functions/tcsetattr.html"><i>tcsetattr</i>()</a> is specified in place of the use of the TCSETA <a href=
"../functions/ioctl.html"><i>ioctl</i>()</a> command function. This allows specification of all the arguments in a manner
consistent with the ISO&nbsp;C standard unlike the varying third argument of <a href="../functions/ioctl.html"><i>ioctl</i>()</a>,
which is sometimes a pointer (to any of many different types) and sometimes an <b>int</b>.</p>

<p>The advantages of this new method include:</p>

<ul>
<li>
<p>It allows strict type checking.</p>
</li>

<li>
<p>The direction of transfer of control data is explicit.</p>
</li>

<li>
<p>Portable capabilities are clearly identified.</p>
</li>

<li>
<p>The need for a general interface routine is avoided.</p>
</li>

<li>
<p>Size of the argument is well-defined (there is only one type).</p>
</li>
</ul>

<p>The disadvantages include:</p>

<ul>
<li>
<p>No historical implementation used the new method.</p>
</li>

<li>
<p>There are many small routines instead of one general-purpose one.</p>
</li>

<li>
<p>The historical parallel with <a href="../functions/fcntl.html"><i>fcntl</i>()</a> is broken.</p>
</li>
</ul>

<p>The issue of modem control was excluded from POSIX.1-2017 on the grounds that:</p>

<ul>
<li>
<p>It was concerned with setting and control of hardware timers.</p>
</li>

<li>
<p>The appropriate timers and settings vary widely internationally.</p>
</li>

<li>
<p>Feedback from European computer manufacturers indicated that this facility was not consistent with European needs and that
specification of such a facility was not a requirement for portability.</p>
</li>
</ul>

<h4><a name="tag_21_11_01">  A.11.1  </a>Interface Characteristics</h4>

<h5><a name="tag_21_11_01_01"></a>Opening a Terminal Device File</h5>

<p>The O_TTY_INIT flag for <a href="../functions/open.html"><i>open</i>()</a> has been added to POSIX.1-2017 to solve a problem
encountered by applications written for earlier versions of this standard which need to open a modem or similar device and
initialize all of the parameter settings. Using the <a href="../functions/tcgetattr.html"><i>tcgetattr</i>()</a>-modify- <a href=
"../functions/tcsetattr.html"><i>tcsetattr</i>()</a> method mandated by the standard could result in non-conforming behavior if the
device had previously been used with non-conforming parameter settings, on implementations which do not reset the parameter
settings in between the last close of the device by one application and the first open by another application. To avoid this
problem, some application developers were resorting to using <a href="../functions/memset.html"><i>memset</i>()</a> to zero the
<b>termios</b> structure before setting all of the standard parameters, but this risks non-conforming behavior on systems where
some non-standard parameter needs a non-zero value in order for the terminal to behave in a conforming manner.</p>

<p>On systems which do reset the parameter settings to defaults between uses of a terminal device, it is expected that either
O_TTY_INIT will have the value zero or <i>open</i>(<i>ttypath</i>, O_RDWR|O_TTY_INIT) will do nothing additional.</p>

<p>The standard developers considered an alternative solution of a special <i>fildes</i> argument for the <a href=
"../functions/tcgetattr.html"><i>tcgetattr</i>()</a> call to obtain default parameters. However, this would not be adequate if a
system supports several different types of terminal device and the default settings need to differ between the different types.
With the O_TTY_INIT open flag, the implementor can determine which device type is being opened.</p>

<p>The standard developers also considered a special POSIX_TTY_INIT value for the <b>termios</b> structure used in <a href=
"../functions/tcsetattr.html"><i>tcsetattr</i>()</a>, which would reset the values if used immediately after an <a href=
"../functions/open.html"><i>open</i>()</a> call. However, it was felt that this would lead to confusion amongst application
developers who wanted to reset the parameters at other points, and implementations might diverge.</p>

<h5><a name="tag_21_11_01_02"></a>Process Groups</h5>

<p>There is a potential race when the members of the foreground process group on a terminal leave that process group, either by
exit or by changing process groups. After the last process exits the process group, but before the foreground process group ID of
the terminal is changed (usually by a job control shell), it would be possible for a new process to be created with its process ID
equal to the terminal's foreground process group ID. That process might then become the process group leader and accidentally be
placed into the foreground on a terminal that was not necessarily its controlling terminal. As a result of this problem, the
controlling terminal is defined to not have a foreground process group during this time.</p>

<p>The cases where a controlling terminal has no foreground process group occur when all processes in the foreground process group
either terminate and are waited for or join other process groups via <a href="../functions/setpgid.html"><i>setpgid</i>()</a> or <a
href="../functions/setsid.html"><i>setsid</i>()</a>. If the process group leader terminates, this is the first case described; if
it leaves the process group via <a href="../functions/setpgid.html"><i>setpgid</i>()</a>, this is the second case described (a
process group leader cannot successfully call <a href="../functions/setsid.html"><i>setsid</i>()</a>). When one of those cases
causes a controlling terminal to have no foreground process group, it has two visible effects on applications. The first is the
value returned by <a href="../functions/tcgetpgrp.html"><i>tcgetpgrp</i>()</a>. The second (which occurs only in the case where the
process group leader terminates) is the sending of signals in response to special input characters. The intent of POSIX.1-2017 is
that no process group be wrongly identified as the foreground process group by <a href=
"../functions/tcgetpgrp.html"><i>tcgetpgrp</i>()</a> or unintentionally receive signals because of placement into the
foreground.</p>

<p>In 4.3 BSD, the old process group ID continues to be used to identify the foreground process group and is returned by the
function equivalent to <a href="../functions/tcgetpgrp.html"><i>tcgetpgrp</i>()</a>. In that implementation it is possible for a
newly created process to be assigned the same value as a process ID and then form a new process group with the same value as a
process group ID. The result is that the new process group would receive signals from this terminal for no apparent reason, and
POSIX.1-2017 precludes this by forbidding a process group from entering the foreground in this way. It would be more direct to
place part of the requirement made by the last sentence under <a href="../functions/fork.html"><i>fork</i>()</a>, but there is no
convenient way for that section to refer to the value that <a href="../functions/tcgetpgrp.html"><i>tcgetpgrp</i>()</a> returns,
since in this case there is no process group and thus no process group ID.</p>

<p>One possibility for a conforming implementation is to behave similarly to 4.3 BSD, but to prevent this reuse of the ID, probably
in the implementation of <a href="../functions/fork.html"><i>fork</i>()</a>, as long as it is in use by the terminal.</p>

<p>Another possibility is to recognize when the last process stops using the terminal's foreground process group ID, which is when
the process group lifetime ends, and to change the terminal's foreground process group ID to a reserved value that is never used as
a process ID or process group ID. (See the definition of <i>process group lifetime</i> in the definitions section.) The process ID
can then be reserved until the terminal has another foreground process group.</p>

<p>The 4.3 BSD implementation permits the leader (and only member) of the foreground process group to leave the process group by
calling the equivalent of <a href="../functions/setpgid.html"><i>setpgid</i>()</a> and to later return, expecting to return to the
foreground. There are no known application needs for this behavior, and POSIX.1-2017 neither requires nor forbids it (except that
it is forbidden for session leaders) by leaving it unspecified.</p>

<h5><a name="tag_21_11_01_03"></a>The Controlling Terminal</h5>

<p>POSIX.1-2017 does not specify a mechanism by which to allocate a controlling terminal. This is normally done by a system utility
(such as <i>getty</i>) and is considered an administrative feature outside the scope of POSIX.1-2017.</p>

<p>Historical implementations allocate controlling terminals on certain <a href="../functions/open.html"><i>open</i>()</a> calls.
Since <a href="../functions/open.html"><i>open</i>()</a> is part of POSIX.1, its behavior had to be dealt with. The traditional
behavior is not required because it is not very straightforward or flexible for either implementations or applications. However,
because of its prevalence, it was not practical to disallow this behavior either. Thus, a mechanism was standardized to ensure
portable, predictable behavior in <a href="../functions/open.html"><i>open</i>()</a>.</p>

<p>Some historical implementations deallocate a controlling terminal on the last system-wide close. This behavior in neither
required nor prohibited. Even on implementations that do provide this behavior, applications generally cannot depend on it due to
its system-wide nature.</p>

<h5><a name="tag_21_11_01_04"></a>Terminal Access Control</h5>

<p>The access controls described in this section apply only to a process that is accessing its controlling terminal. A process
accessing a terminal that is not its controlling terminal is effectively treated the same as a member of the foreground process
group. While this may seem unintuitive, note that these controls are for the purpose of job control, not security, and job control
relates only to the controlling terminal of a process. Normal file access permissions handle security.</p>

<p>If the process calling <a href="../functions/read.html"><i>read</i>()</a> or <a href=
"../functions/write.html"><i>write</i>()</a> is in a background process group that is orphaned, it is not desirable to stop the
process group, as it is no longer under the control of a job control shell that could put it into the foreground again.
Accordingly, calls to <a href="../functions/read.html"><i>read</i>()</a> or <a href="../functions/write.html"><i>write</i>()</a>
functions by such processes receive an immediate error return. This is different from 4.2 BSD, which kills orphaned processes that
receive terminal stop signals.</p>

<p>The foreground/background/orphaned process group check performed by the terminal driver must be repeatedly performed until the
calling process moves into the foreground or until the process group of the calling process becomes orphaned. That is, when the
terminal driver determines that the calling process is in the background and should receive a job control signal, it sends the
appropriate signal (SIGTTIN or SIGTTOU) to every process in the process group of the calling process and then it allows the calling
process to immediately receive the signal. The latter is typically performed by blocking the process so that the signal is
immediately noticed. Note, however, that after the process finishes receiving the signal and control is returned to the driver, the
terminal driver must re-execute the foreground/background/orphaned process group check. The process may still be in the background,
either because it was continued in the background by a job control shell, or because it caught the signal and did nothing.</p>

<p>The terminal driver repeatedly performs the foreground/background/orphaned process group checks whenever a process is about to
access the terminal. In the case of <a href="../functions/write.html"><i>write</i>()</a> or the control <a href=
"../functions/tc*.html"><i>tc*</i>()</a> functions, the check is performed at the entry of the function. In the case of <a href=
"../functions/read.html"><i>read</i>()</a>, the check is performed not only at the entry of the function, but also after blocking
the process to wait for input characters (if necessary). That is, once the driver has determined that the process calling the <a
href="../functions/read.html"><i>read</i>()</a> function is in the foreground, it attempts to retrieve characters from the input
queue. If the queue is empty, it blocks the process waiting for characters. When characters are available and control is returned
to the driver, the terminal driver must return to the repeated foreground/background/orphaned process group check again. The
process may have moved from the foreground to the background while it was blocked waiting for input characters.</p>

<h5><a name="tag_21_11_01_05"></a>Input Processing and Reading Data</h5>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_21_11_01_06"></a>Canonical Mode Input Processing</h5>

<p>The term &quot;character&quot; is intended here. ERASE should erase the last character, not the last byte. In the case of multi-byte
characters, these two may be different.</p>

<p>4.3 BSD has a WERASE character that erases the last &quot;word&quot; typed (but not any preceding &lt;blank&gt; or &lt;tab&gt;
characters). A word is defined as a sequence of non- &lt;blank&gt; characters, with &lt;tab&gt; characters counted as &lt;blank&gt;
characters. Like ERASE, WERASE does not erase beyond the beginning of the line. This WERASE feature has not been specified in
POSIX.1 because it is difficult to define in the international environment. It is only useful for languages where words are
delimited by &lt;blank&gt; characters. In some ideographic languages, such as Japanese and Chinese, words are not delimited at all.
The WERASE character should presumably go back to the beginning of a sentence in those cases; practically, this means it would not
be used much for those languages.</p>

<p>It should be noted that there is a possible inherent deadlock if the application and implementation conflict on the value of
{MAX_CANON}. With ICANON set (if IXOFF is enabled) and more than {MAX_CANON} characters transmitted without a &lt;linefeed&gt;,
transmission will be stopped, the &lt;linefeed&gt; (or &lt;carriage-return&gt; when ICRLF is set) will never arrive, and the <a
href="../functions/read.html"><i>read</i>()</a> will never be satisfied.</p>

<p>An application should not set IXOFF if it is using canonical mode unless it knows that (even in the face of a transmission
error) the conditions described previously cannot be met or unless it is prepared to deal with the possible deadlock in some other
way, such as timeouts.</p>

<p>It should also be noted that this can be made to happen in non-canonical mode if the trigger value for sending IXOFF is less
than VMIN and VTIME is zero.</p>

<h5><a name="tag_21_11_01_07"></a>Non-Canonical Mode Input Processing</h5>

<p>Some points to note about MIN and TIME:</p>

<ol>
<li>
<p>The interactions of MIN and TIME are not symmetric. For example, when MIN&gt;0 and TIME=0, TIME has no effect. However, in the
opposite case where MIN=0 and TIME&gt;0, both MIN and TIME play a role in that MIN is satisfied with the receipt of a single
character.</p>
</li>

<li>
<p>Also note that in case A (MIN&gt;0, TIME&gt;0), TIME represents an inter-character timer, while in case C (MIN=0, TIME&gt;0),
TIME represents a read timer.</p>
</li>
</ol>

<p>These two points highlight the dual purpose of the MIN/TIME feature. Cases A and B, where MIN&gt;0, exist to handle burst-mode
activity (for example, file transfer programs) where a program would like to process at least MIN characters at a time. In case A,
the inter-character timer is activated by a user as a safety measure; in case B, it is turned off.</p>

<p>Cases C and D exist to handle single-character timed transfers. These cases are readily adaptable to screen-based applications
that need to know if a character is present in the input queue before refreshing the screen. In case C, the read is timed; in case
D, it is not.</p>

<p>Another important note is that MIN is always just a minimum. It does not denote a record length. That is, if a program does a
read of 20 bytes, MIN is 10, and 25 characters are present, 20 characters are returned to the user. In the special case of MIN=0,
this still applies: if more than one character is available, they all will be returned immediately.</p>

<h5><a name="tag_21_11_01_08"></a>Writing Data and Output Processing</h5>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_21_11_01_09"></a>Special Characters</h5>

<p>POSIX.1-2008, Technical Corrigendum 2, XBD/TC2-2008/0055 [745] is applied.</p>

<h5><a name="tag_21_11_01_10"></a>Modem Disconnect</h5>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_21_11_01_11"></a>Closing a Terminal Device File</h5>

<p>POSIX.1-2017 does not specify that a <a href="../functions/close.html"><i>close</i>()</a> on a terminal device file include the
equivalent of a call to <i>tcflow</i>(<i>fd</i>,TCOON).</p>

<p>An implementation that discards output at the time <a href="../functions/close.html"><i>close</i>()</a> is called after
reporting the return value to the <a href="../functions/write.html"><i>write</i>()</a> call that data was written does not conform
with POSIX.1-2017. An application has functions such as <a href="../functions/tcdrain.html"><i>tcdrain</i>()</a>, <a href=
"../functions/tcflush.html"><i>tcflush</i>()</a>, and <a href="../functions/tcflow.html"><i>tcflow</i>()</a> available to obtain
the detailed behavior it requires with respect to flushing of output.</p>

<p>At the time of the last close on a terminal device, an application relinquishes any ability to exert flow control via <a href=
"../functions/tcflow.html"><i>tcflow</i>()</a>.</p>

<h4><a name="tag_21_11_02">  A.11.2  </a>Parameters that Can be Set</h4>

<h5><a name="tag_21_11_02_01"></a>The termios Structure</h5>

<p>This structure is part of an interface that, in general, retains the historic grouping of flags. Although a more optimal
structure for implementations may be possible, the degree of change to applications would be significantly larger.</p>

<h5><a name="tag_21_11_02_02"></a>Input Modes</h5>

<p>Some historical implementations treated a long break as multiple events, as many as one per character time. The wording in
POSIX.1 explicitly prohibits this.</p>

<p>Although the ISTRIP flag is normally superfluous with today's terminal hardware and software, it is historically supported.
Therefore, applications may be using ISTRIP, and there is no technical problem with supporting this flag. Also, applications may
wish to receive only 7-bit input bytes and may not be connected directly to the hardware terminal device (for example, when a
connection traverses a network).</p>

<p>Also, there is no requirement in general that the terminal device ensures that high-order bits beyond the specified character
size are cleared. ISTRIP provides this function for 7-bit characters, which are common.</p>

<p>In dealing with multi-byte characters, the consequences of a parity error in such a character, or in an escape sequence
affecting the current character set, are beyond the scope of POSIX.1 and are best dealt with by the application processing the
multi-byte characters.</p>

<h5><a name="tag_21_11_02_03"></a>Output Modes</h5>

<p>POSIX.1 does not describe post-processing of output to a terminal or detailed control of that from a conforming application.
(That is, translation of &lt;newline&gt; to &lt;carriage-return&gt; followed by &lt;linefeed&gt; or &lt;tab&gt; processing.) There
is nothing that a conforming application should do to its output for a terminal because that would require knowledge of the
operation of the terminal. It is the responsibility of the operating system to provide post-processing appropriate to the output
device, whether it is a terminal or some other type of device.</p>

<p>Extensions to POSIX.1 to control the type of post-processing already exist and are expected to continue into the future. The
control of these features is primarily to adjust the interface between the system and the terminal device so the output appears on
the display correctly. This should be set up before use by any application.</p>

<p>In general, both the input and output modes should not be set absolutely, but rather modified from the inherited state.</p>

<h5><a name="tag_21_11_02_04"></a>Control Modes</h5>

<p>This section could be misread that the symbol &quot;CSIZE&quot; is a title in the <b>termios</b> <i>c_cflag</i> field. Although it does
serve that function, it is also a required symbol, as a literal reading of POSIX.1 (and the caveats about typography) would
indicate.</p>

<h5><a name="tag_21_11_02_05"></a>Local Modes</h5>

<p>Non-canonical mode is provided to allow fast bursts of input to be read efficiently while still allowing single-character
input.</p>

<p>The ECHONL function historically has been in many implementations. Since there seems to be no technical problem with supporting
ECHONL, it is included in POSIX.1 to increase consensus.</p>

<p>The alternate behavior possible when ECHOK or ECHOE are specified with ICANON is permitted as a compromise depending on what the
actual terminal hardware can do. Erasing characters and lines is preferred, but is not always possible.</p>

<h5><a name="tag_21_11_02_06"></a>Special Control Characters</h5>

<p>Permitting VMIN and VTIME to overlap with VEOF and VEOL was a compromise for historical implementations. Only when
backwards-compatibility of object code is a serious concern to an implementor should an implementation continue this practice.
Correct applications that work with the overlap (at the source level) should also work if it is not present, but not the
reverse.</p>

<p>&nbsp;</p>

<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
Copyright &copy; 2001-2018 IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../xrat/V4_xbd_chap10.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../xrat/V4_xbd_chap12.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>
</body>
</html>

