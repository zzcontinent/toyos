<!-- Copyright 2001-2013 IEEE and The Open Group, All Rights Reserved -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group's rhtm tool v1.2.4 -->
<!-- Copyright (c) 2001-2013 The Open Group, All Rights Reserved -->
<title>Shell Command Language</title>
</head>
<body bgcolor="white">
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../xrat/V4_xcu_chap01.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../xrat/V4_xcu_chap03.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>


<basefont size="3"> 

<center><font size="2">The Open Group Base Specifications Issue 7, 2018 edition<br>
IEEE Std 1003.1-2017 (Revision of IEEE Std 1003.1-2008)<br>
Copyright &copy; 2001-2018 IEEE and The Open Group</font></center>

<hr size="2" noshade>
<a name="top"></a> 

<h3><a name="tag_23_02">   C.2  </a>Shell Command Language</h3>

<h4><a name="tag_23_02_01">  C.2.1  </a>Shell Introduction</h4>

<p>The System&nbsp;V shell was selected as the starting point for the Shell and Utilities volume of POSIX.1-2017. The BSD C shell
was excluded from consideration for the following reasons:</p>

<ul>
<li>
<p>Most historically portable shell scripts assume the Version 7 Bourne shell, from which the System&nbsp;V shell is derived.</p>
</li>

<li>
<p>The majority of tutorial materials on shell programming assume the System V shell.</p>
</li>
</ul>

<p>The construct <tt>"#!"</tt> is reserved for implementations wishing to provide that extension. If it were not reserved, the
Shell and Utilities volume of POSIX.1-2017 would disallow it by forcing it to be a comment. As it stands, a strictly conforming
application must not use <tt>"#!"</tt> as the first two characters of the file.</p>

<h4><a name="tag_23_02_02">  C.2.2  </a>Quoting</h4>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_23_02_02_01"></a>Escape Character (Backslash)</h5>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_23_02_02_02"></a>Single-Quotes</h5>

<p>A &lt;backslash&gt; cannot be used to escape a single-quote in a single-quoted string. An embedded quote can be created by
writing, for example: <tt>"'a'\''b'"</tt>, which yields <tt>"a'b"</tt>. (See XCU <a href=
"../utilities/V3_chap02.html#tag_18_06_05"><i>Field Splitting</i></a> for a better understanding of how portions of words are
either split into fields or remain concatenated.) A single token can be made up of concatenated partial strings containing all
three kinds of quoting or escaping, thus permitting any combination of characters.</p>

<h5><a name="tag_23_02_02_03"></a>Double-Quotes</h5>

<p>The escaped &lt;newline&gt; used for line continuation is removed entirely from the input and is not replaced by any white
space. Therefore, it cannot serve as a token separator.</p>

<p>In double-quoting, if a &lt;backslash&gt; is immediately followed by a character that would be interpreted as having a special
meaning, the &lt;backslash&gt; is deleted and the subsequent character is taken literally. If a &lt;backslash&gt; does not precede
a character that would have a special meaning, it is left in place unmodified and the character immediately following it is also
left unmodified. Thus, for example:</p>

<pre>
<tt>"\$"  -&gt;  $
<br>
"\a"  -&gt;  \a
</tt>
</pre>

<p>It would be desirable to include the statement &quot;The characters from an enclosed <tt>"${"</tt> to the matching <tt>'}'</tt>
shall not be affected by the double-quotes&quot;, similar to the one for <tt>"$()"</tt>. However, historical practice in the
System&nbsp;V shell prevents this.</p>

<p>The requirement that double-quotes be matched inside <tt>"${...}"</tt> within double-quotes and the rule for finding the
matching <tt>'}'</tt> in XCU <a href="../utilities/V3_chap02.html#tag_18_06_02"><i>Parameter Expansion</i></a> eliminate several
subtle inconsistencies in expansion for historical shells in rare cases; for example:</p>

<pre>
<tt>"${foo-bar"}
</tt>
</pre>

<p>yields <b>bar</b> when <b>foo</b> is not defined, and is an invalid substitution when <b>foo</b> is defined, in many historical
shells. The differences in processing the <tt>"${...}"</tt> form have led to inconsistencies between historical systems. A
consequence of this rule is that single-quotes cannot be used to quote the <tt>'}'</tt> within <tt>"${...}"</tt>; for example:</p>

<pre>
<tt>unset bar
foo="${bar-'}'}"
</tt>
</pre>

<p>is invalid because the <tt>"${...}"</tt> substitution contains an unpaired unescaped single-quote. The &lt;backslash&gt; can be
used to escape the <tt>'}'</tt> in this example to achieve the desired result:</p>

<pre>
<tt>unset bar
foo="${bar-\}}"
</tt>
</pre>

<p>The differences in processing the <tt>"${...}"</tt> form have led to inconsistencies between the historical System&nbsp;V shell,
BSD, and KornShells, and the text in the Shell and Utilities volume of POSIX.1-2017 is an attempt to converge them without breaking
too many applications. The only alternative to this compromise between shells would be to make the behavior unspecified whenever
the literal characters single-quote, <tt>'{'</tt>, <tt>'}'</tt>, and <tt>''</tt> appear within <tt>"${...}"</tt>. To write a
portable script that uses these values, a user would have to assign variables; for example:</p>

<pre>
<tt>squote=\' dquote=\" lbrace='{' rbrace='}'
${foo-$squote$rbrace$squote}
</tt>
</pre>

<p>rather than:</p>

<pre>
<tt>${foo-"'}'"}
</tt>
</pre>

<p>Some implementations have allowed the end of the word to terminate the backquoted command substitution, such as in:</p>

<pre>
<tt>"`echo hello"
</tt>
</pre>

<p>This usage is undefined; the matching backquote is required by the Shell and Utilities volume of POSIX.1-2017. The other
undefined usage can be illustrated by the example:</p>

<pre>
<tt>sh -c '` echo "foo`'
</tt>
</pre>

<p>The description of the recursive actions involving command substitution can be illustrated with an example. Upon recognizing the
introduction of command substitution, the shell parses input (in a new context), gathering the source for the command substitution
until an unbalanced <tt>')'</tt> or <tt>'`'</tt> is located. For example, in the following:</p>

<pre>
<tt>echo "$(date; echo "
    one" )"
</tt>
</pre>

<p>the double-quote following the <a href="../utilities/echo.html"><i>echo</i></a> does not terminate the first double-quote; it is
part of the command substitution script. Similarly, in:</p>

<pre>
<tt>echo "$(echo *)"
</tt>
</pre>

<p>the &lt;asterisk&gt; is not quoted since it is inside command substitution; however:</p>

<pre>
<tt>echo "$(echo "*")"
</tt>
</pre>

<p>is quoted (and represents the &lt;asterisk&gt; character itself).</p>

<h4><a name="tag_23_02_03">  C.2.3  </a>Token Recognition</h4>

<p>The <tt>"(("</tt> and <tt>"))"</tt> symbols are control operators in the KornShell, used for an alternative syntax of an
arithmetic expression command. A conforming application cannot use <tt>"(("</tt> as a single token (with the exception of the
<tt>"$(("</tt> form for shell arithmetic).</p>

<p>On some implementations, the symbol <tt>"(("</tt> is a control operator; its use produces unspecified results. Applications that
wish to have nested subshells, such as:</p>

<pre>
<tt>((echo Hello);(echo World))
</tt>
</pre>

<p>must separate the <tt>"(("</tt> characters into two tokens by including white space between them. Some systems may treat these
as invalid arithmetic expressions instead of subshells.</p>

<p>Certain combinations of characters are invalid in portable scripts, as shown in the grammar. Implementations may use these
combinations (such as <tt>"|&amp;"</tt> ) as valid control operators. Portable scripts cannot rely on receiving errors in all cases
where this volume of POSIX.1-2017 indicates that a syntax is invalid.</p>

<p>The (3) rule about combining characters to form operators is not meant to preclude systems from extending the shell language
when characters are combined in otherwise invalid ways. Conforming applications cannot use invalid combinations, and test suites
should not penalize systems that take advantage of this fact. For example, the unquoted combination <tt>"|&amp;"</tt> is not valid
in a POSIX script, but has a specific KornShell meaning.</p>

<p>The (10) rule about <tt>'#'</tt> as the current character is the first in the sequence in which a new token is being assembled.
The <tt>'#'</tt> starts a comment only when it is at the beginning of a token. This rule is also written to indicate that the
search for the end-of-comment does not consider escaped &lt;newline&gt; specially, so that a comment cannot be continued to the
next line.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0005 [718], XCU/TC2-2008/0006 [647], XCU/TC2-2008/0007 [568], and
XCU/TC2-2008/0008 [648] are applied.</p>

<h5><a name="tag_23_02_03_01"></a>Alias Substitution</h5>

<p>The alias capability was added because it is widely used in historical implementations by interactive users.</p>

<p>The definition of &quot;alias name&quot; precludes an alias name containing a &lt;slash&gt; character. Since the text applies to the
command words of simple commands, reserved words (in their proper places) cannot be confused with aliases.</p>

<p>The placement of alias substitution in token recognition makes it clear that it precedes all of the word expansion steps.</p>

<p>An example concerning trailing &lt;blank&gt; characters and reserved words follows. If the user types:</p>

<pre>
<b>$</b> <tt>alias foo="/bin/ls "
</tt><b>$</b> <tt>alias while="/"
</tt>
</pre>

<p>The effect of executing:</p>

<pre>
<b>$</b> <tt>while true
</tt><b>&gt;</b> <tt>do
</tt><b>&gt;</b> <tt>echo "Hello, World"
</tt><b>&gt;</b> <tt>done
</tt>
</pre>

<p>is a never-ending sequence of <tt>"Hello, World"</tt> strings to the screen. However, if the user types:</p>

<pre>
<b>$</b> <tt>foo while
</tt>
</pre>

<p>the result is an <a href="../utilities/ls.html"><i>ls</i></a> listing of <b>/</b>. Since the alias substitution for <b>foo</b>
ends in a &lt;space&gt;, the next word is checked for alias substitution. The next word, <b>while</b>, has also been aliased, so it
is substituted as well. Since it is not in the proper position as a command word, it is not recognized as a reserved word.</p>

<p>If the user types:</p>

<pre>
<b>$</b> <tt>foo; while
</tt>
</pre>

<p><b>while</b> retains its normal reserved-word properties.</p>

<h4><a name="tag_23_02_04">  C.2.4  </a>Reserved Words</h4>

<p>All reserved words are recognized syntactically as such in the contexts described. However, note that <b>in</b> is the only
meaningful reserved word after a <b>case</b> or <b>for</b>; similarly, <b>in</b> is not meaningful as the first word of a simple
command.</p>

<p>Reserved words are recognized only when they are delimited (that is, meet the definition of XBD <a href=
"../basedefs/V1_chap03.html#tag_03_446"><i>Word</i></a>), whereas operators are themselves delimiters. For instance, <tt>'('</tt>
and <tt>')'</tt> are control operators, so that no &lt;space&gt; is needed in (<i>list</i>). However, <tt>'{'</tt> and <tt>'}'</tt>
are reserved words in {&nbsp;<i>list</i>;}, so that in this case the leading &lt;space&gt; and &lt;semicolon&gt; are required.</p>

<p>The list of unspecified reserved words is from the KornShell, so conforming applications cannot use them in places a reserved
word would be recognized. This list contained <b>time</b> in early proposals, but it was removed when the <a href=
"../utilities/time.html"><i>time</i></a> utility was selected for the Shell and Utilities volume of POSIX.1-2017.</p>

<p>There was a strong argument for promoting braces to operators (instead of reserved words), so they would be syntactically
equivalent to subshell operators. Concerns about compatibility outweighed the advantages of this approach. Nevertheless, conforming
applications should consider quoting <tt>'{'</tt> and <tt>'}'</tt> when they represent themselves.</p>

<p>The restriction on ending a name with a &lt;colon&gt; is to allow future implementations that support named labels for flow
control; see the RATIONALE for the <a href="../utilities/V3_chap02.html#tag_18_15"><i>break</i></a> built-in utility.</p>

<p>It is possible that a future version of the Shell and Utilities volume of POSIX.1-2017 may require that <tt>'{'</tt> and
<tt>'}'</tt> be treated individually as control operators, although the token <tt>"{}"</tt> will probably be a special-case
exemption from this because of the often-used <a href="../utilities/find.html"><i>find</i></a>{} construct.</p>

<h4><a name="tag_23_02_05">  C.2.5  </a>Parameters and Variables</h4>

<h5><a name="tag_23_02_05_01"></a>Positional Parameters</h5>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_23_02_05_02"></a>Special Parameters</h5>

<p>Most historical implementations implement subshells by forking; thus, the special parameter <tt>'$'</tt> does not necessarily
represent the process ID of the shell process executing the commands since the subshell execution environment preserves the value
of <tt>'$'</tt>.</p>

<p>If a subshell were to execute a background command, the value of <tt>"$!"</tt> for the parent would not change. For example:</p>

<pre>
<tt>(
date &amp;
echo $!
)
echo $!
</tt>
</pre>

<p>would echo two different values for <tt>"$!"</tt>.</p>

<p>The <tt>"$-"</tt> special parameter can be used to save and restore <a href="../utilities/V4_xcu_chap02.html#set"><i>set</i></a>
options:</p>

<pre>
<tt>Save=$(echo $- | sed 's/[ics]//g')
...
set +aCefnuvx
if [ -n "$Save" ]; then
    set -$Save
fi
</tt>
</pre>

<p>The three options are removed using <a href="../utilities/sed.html"><i>sed</i></a> in the example because they may appear in the
value of <tt>"$-"</tt> (from the <a href="../utilities/sh.html"><i>sh</i></a> command line), but are not valid options to <a href=
"../utilities/V4_xcu_chap02.html#set"><i>set</i></a>.</p>

<p>The descriptions of parameters <tt>'*'</tt> and <tt>'@'</tt> assume the reader is familiar with the field splitting discussion
in XCU <a href="../utilities/V3_chap02.html#tag_18_06_05"><i>Field Splitting</i></a> and understands that portions of the word
remain concatenated unless there is some reason to split them into separate fields.</p>

<p>The following examples illustrate some of the ways in which <tt>'*'</tt> and <tt>'@'</tt> can be expanded:</p>

<pre>
<tt>set "abc" "def ghi" "jkl"
unset novar
IFS=' ' # a space
printf '%s\n' $*
</tt><b>abc
def
ghi
jkl</b><tt>printf '%s\n' "$*"
</tt><b>abc def ghi jkl</b><tt>printf '%s\n' xx$*yy
</tt><b>xxabc
def
ghi
jklyy</b><tt>printf '%s\n' "xx$*yy"
</tt><b>xxabc def ghi jklyy</b><tt>printf '%s\n' $@
</tt><b>abc
def
ghi
jkl</b><tt>printf '%s\n' "$@"
</tt><b>abc
def ghi
jkl</b><tt>printf '%s\n' ${1+"$@"}
</tt><b>abc
def ghi
jkl</b><tt>printf '%s\n' ${novar-"$@"}
</tt><b>abc
def ghi
jkl</b><tt>printf '%s\n' xx$@yy
</tt><b>xxabc
def
ghi
jklyy</b><tt>printf '%s\n' "xx$@yy"
</tt><b>xxabc
def ghi
jklyy</b><tt>printf '%s\n' $@$@
</tt><b>abc
def
ghi
jklabc
def
ghi
jkl</b><tt>printf '%s\n' "$@$@"
</tt><b>abc
def ghi
jklabc
def ghi
jkl</b><tt>IFS=':'
printf '%s\n' "$*"
</tt><b>abc:def ghi:jkl</b><tt>var=$*; printf '%s\n' "$var"
</tt><b>abc:def ghi:jkl</b><tt>var="$*"; printf '%s\n' "$var"
</tt><b>abc:def ghi:jkl</b><tt>unset var
printf '%s\n' ${var-$*}
</tt><b>abc
def ghi
jkl</b><tt>printf '%s\n' "${var-$*}"
</tt><b>abc:def ghi:jkl</b><tt>printf '%s\n' ${var-"$*"}
</tt><b>abc:def ghi:jkl</b><tt>printf '%s\n' ${var=$*}
</tt><b>abc
def ghi
jkl</b><tt>printf 'var=%s\n' "$var"
</tt><b>var=abc:def ghi:jkl</b><tt>unset var
printf '%s\n' "${var=$*}"
</tt><b>abc:def ghi:jkl</b><tt>printf 'var=%s\n' "$var"
</tt><b>var=abc:def ghi:jkl</b><tt><br>
IFS=&quot; # null
printf '%s\n' "$*"
</tt><b>abcdef ghijkl</b><tt>var=$*; printf '%s\n' "$var"
</tt><b>abcdef ghijkl</b><tt>var="$*"; printf '%s\n' "$var"
</tt><b>abcdef ghijkl</b><tt>unset var
printf '%s\n' ${var-$*}
</tt><b>abcdef ghijkl</b><tt>printf '%s\n' "${var-$*}"
</tt><b>abcdef ghijkl</b><tt>printf '%s\n' ${var-"$*"}
</tt><b>abcdef ghijkl</b><tt>printf '%s\n' ${var=$*}
</tt><b>abcdef ghijkl</b><tt>printf 'var=%s\n' "$var"
</tt><b>var=abcdef ghijkl</b><tt>unset var
printf '%s\n' "${var=$*}"
</tt><b>abcdef ghijkl</b><tt>printf 'var=%s\n' "$var"
</tt><b>var=abcdef ghijkl</b><tt>printf '%s\n' "$@"
</tt><b>abc
def ghi
jkl</b><tt><br>
unset IFS
printf '%s\n' "$*"
</tt><b>abc def ghi jkl</b><tt>var=$*; printf '%s\n' "$var"
</tt><b>abc def ghi jkl</b><tt>var="$*"; printf '%s\n' "$var"
</tt><b>abc def ghi jkl</b><tt>unset var
printf '%s\n' ${var-$*}
</tt><b>abc
def
ghi
jkl</b><tt>printf '%s\n' "${var-$*}"
</tt><b>abc def ghi jkl</b><tt>printf '%s\n' ${var-"$*"}
</tt><b>abc def ghi jkl</b><tt>printf '%s\n' ${var=$*}
</tt><b>abc
def
ghi
jkl</b><tt>printf 'var=%s\n' "$var"
</tt><b>var=abc def ghi jkl</b><tt>unset var
printf '%s\n' "${var=$*}"
</tt><b>abc def ghi jkl</b><tt>printf 'var=%s\n' "$var"
</tt><b>var=abc def ghi jkl</b><tt>printf '%s\n' "$@"
</tt><b>abc
def ghi
jkl</b><tt><br>
set one "" three
printf '[%s]\n' $*
</tt><b>[one]
[]</b> <tt></tt>(<i>this line of output is optional</i>)<b>[three]</b><tt>printf '[%s]\n' $@
</tt><b>[one]
[]</b> <tt></tt>(<i>this line of output is optional</i>)<b>[three]</b><tt><br>
set --
printf '[%s]\n' foo "$*"
</tt><b>[foo]
[]</b><tt>printf '[%s]\n' foo "$novar$*$(echo)"
</tt><b>[foo]
[]</b><tt>printf '[%s]\n' foo $@
</tt><b>[foo]</b><tt>printf '[%s]\n' foo "$@"
</tt><b>[foo]</b><tt>printf '[%s]\n' foo ''$@
</tt><b>[foo]
[]</b><tt>printf '[%s]\n' foo ''"$@"
</tt><b>[foo]
[]</b><tt>printf '[%s]\n' foo "$novar$@$(echo)"
</tt><b>[foo]
[]</b> <tt></tt>(<i>this line of output is optional</i>)<tt>printf '[%s]\n' foo ''"$novar$@$(echo)"
</tt><b>[foo]
[]</b>
</pre>

<p>In all of the following commands the results of the expansion of <tt>'@'</tt> (if performed) are unspecified:</p>

<pre>
<tt>var=$@
var="$@"
printf '%s\n' ${var=$@}
printf '%s\n' "${var=$@}"
printf '%s\n' ${var="$@"}
printf '%s\n' ${var?$@}
printf '%s\n' "${var?$@}"
printf '%s\n' ${var?"$@"}
printf '%s\n' ${#@}
printf '%s\n' "${#@}"
printf '%s\n' ${@%foo}
printf '%s\n' "${@%foo}"
printf '%s\n' ${@#foo}
printf '%s\n' "${@#foo}"
printf '%s\n' ${var%$@}
printf '%s\n' "${var%$@}"
printf '%s\n' ${var%"$@"}
printf '%s\n' ${var%%$@}
printf '%s\n' "${var%%$@}"
printf '%s\n' ${var%%"$@"}
printf '%s\n' ${var#$@}
printf '%s\n' "${var#$@}"
printf '%s\n' ${var#"$@"}
printf '%s\n' ${var##$@}
printf '%s\n' "${var##$@}"
printf '%s\n' ${var##"$@"}
</tt>
</pre>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0009 [888] is applied.</p>

<h5><a name="tag_23_02_05_03"></a>Shell Variables</h5>

<p>See the discussion of <i>IFS</i> in <a href="#tag_23_02_06_05">Field Splitting</a> and the RATIONALE for the <a href=
"../utilities/sh.html"><i>sh</i></a> utility.</p>

<p>The prohibition on <i>LC_CTYPE</i> changes affecting lexical processing protects the shell implementor (and the shell
programmer) from the ill effects of changing the definition of &lt;blank&gt; or the set of alphabetic characters in the current
environment. It would probably not be feasible to write a compiled version of a shell script without this rule. The rule applies
only to the current invocation of the shell and its subshells-invoking a shell script or performing <a href=
"../utilities/V4_xcu_chap02.html#exec"><i>exec</i></a> <a href="../utilities/sh.html"><i>sh</i></a> would subject the new shell to
the changes in <i>LC_CTYPE.</i></p>

<p>Other common environment variables used by historical shells are not specified by the Shell and Utilities volume of
POSIX.1-2017, but they should be reserved for the historical uses.</p>

<p>Tilde expansion for components of <i>PATH</i> in an assignment such as:</p>

<pre>
<tt>PATH=&#152;hlj/bin:&#152;dwc/bin:$PATH
</tt>
</pre>

<p>is a feature of some historical shells and is allowed by the wording of XCU <a href=
"../utilities/V3_chap02.html#tag_18_06_01"><i>Tilde Expansion</i></a>. Note that the &lt;tilde&gt; characters are expanded during
the assignment to <i>PATH,</i> not when <i>PATH</i> is accessed during command search.</p>

<p>The following entries represent additional information about variables included in the Shell and Utilities volume of
POSIX.1-2017, or rationale for common variables in use by shells that have been excluded:</p>

<dl compact>
<dt><tt>_</tt></dt>

<dd>(Underscore.) While &lt;underscore&gt; is historical practice, its overloaded usage in the KornShell is confusing, and it has
been omitted from the Shell and Utilities volume of POSIX.1-2017.</dd>

<dt><i>ENV</i></dt>

<dd>This variable can be used to set aliases and other items local to the invocation of a shell. The file referred to by <i>ENV</i>
differs from <b>$HOME/.profile</b> in that <b>.profile</b> is typically executed at session start-up, whereas the <i>ENV</i> file
is executed at the beginning of each shell invocation. The <i>ENV</i> value is interpreted in a manner similar to a dot script, in
that the commands are executed in the current environment and the file needs to be readable, but not executable. However, unlike
dot scripts, no <i>PATH</i> searching is performed. This is used as a guard against Trojan Horse security breaches.</dd>

<dt><i>ERRNO</i></dt>

<dd>This variable was omitted from the Shell and Utilities volume of POSIX.1-2017 because the values of error numbers are not
defined in POSIX.1-2017 in a portable manner.</dd>

<dt><i>FCEDIT</i></dt>

<dd>Since this variable affects only the <a href="../utilities/fc.html"><i>fc</i></a> utility, it has been omitted from this more
global place. The value of <i>FCEDIT</i> does not affect the command-line editing mode in the shell; see the description of <a
href="../utilities/V4_xcu_chap02.html#set"><i>set</i></a> <b>-o</b> <i>vi</i> in the <a href=
"../utilities/V4_xcu_chap02.html#set"><i>set</i></a> built-in utility.</dd>

<dt><i>PS1</i></dt>

<dd>This variable is used for interactive prompts. Historically, the &quot;superuser&quot; has had a prompt of <tt>'#'</tt>. Since
privileges are not required to be monolithic, it is difficult to define which privileges should cause the alternate prompt.
However, a sufficiently powerful user should be reminded of that power by having an alternate prompt.</dd>

<dt><i>PS3</i></dt>

<dd>This variable is used by the KornShell for the <i>select</i> command. Since the POSIX shell does not include <i>select</i>,
<i>PS3</i> was omitted.</dd>

<dt><i>PS4</i></dt>

<dd>This variable is used for shell debugging. For example, the following script: 

<pre>
<tt>PS4='[${LINENO}]+ '
set -x
echo Hello
</tt>
</pre>

<p>writes the following to standard error:</p>

<pre>
<tt>[3]+ echo Hello
</tt>
</pre>
</dd>

<dt><i>RANDOM</i></dt>

<dd>This pseudo-random number generator was not seen as being useful to interactive users.</dd>

<dt><i>SECONDS</i></dt>

<dd>Although this variable is sometimes used with <i>PS1</i> to allow the display of the current time in the prompt of the user, it
is not one that would be manipulated frequently enough by an interactive user to include in the Shell and Utilities volume of
POSIX.1-2017.</dd>
</dl>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0002 [152] is applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0010 [888], XCU/TC2-2008/0011 [884], and XCU/TC2-2008/0012 [494] are
applied.</p>

<h4><a name="tag_23_02_06">  C.2.6  </a>Word Expansions</h4>

<p>Step (2) refers to the &quot;portions of fields generated by step (1)&quot;. For example, if the word being expanded were
<tt>"$x+$y"</tt> and <i>IFS =+,</i> the word would be split only if <tt>"$x"</tt> or <tt>"$y"</tt> contained <tt>'+'</tt>; the
<tt>'+'</tt> in the original word was not generated by step (1).</p>

<p><i>IFS</i> is used for performing field splitting on the results of parameter and command substitution; it is not used for
splitting all fields. Earlier versions of the shell used it for splitting all fields during field splitting, but this has severe
problems because the shell can no longer parse its own script. There are also important security implications caused by this
behavior. All useful applications of <i>IFS</i> use it for parsing input of the <a href="../utilities/read.html"><i>read</i></a>
utility and for splitting the results of parameter and command substitution.</p>

<p>The rule concerning expansion to a single field requires that if <b>foo</b>= <b>abc</b> and <b>bar</b>= <b>def</b>, that:</p>

<pre>
<tt>"$foo""$bar"
</tt>
</pre>

<br>
<p>expands to the single field:</p>

<pre>
<tt>abcdef
</tt>
</pre>

<p>The rule concerning empty fields can be illustrated by:</p>

<pre>
<b>$</b> <tt>   unset foo
</tt><b>$</b> <tt>   set $foo bar &quot; xyz "$foo" abc
</tt><b>$</b> <tt>   for i
</tt><b>&gt;</b> <tt>   do
</tt><b>&gt;</b> <tt>       echo "-$i-"
</tt><b>&gt;</b> <tt>   done
</tt><b>-bar-
--
-xyz-
--
-abc-</b>
</pre>

<p>Step (1) indicates that parameter expansion, command substitution, and arithmetic expansion are all processed simultaneously as
they are scanned. For example, the following is valid arithmetic:</p>

<pre>
<tt>x=1
echo $(( $(echo 3)+$x ))
</tt>
</pre>

<p>An early proposal stated that tilde expansion preceded the other steps, but this is not the case in known historical
implementations; if it were, and if a referenced home directory contained a <tt>'$'</tt> character, expansions would result within
the directory name.</p>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0003 [49,430] is applied.</p>

<h5><a name="tag_23_02_06_01"></a>Tilde Expansion</h5>

<p>Tilde expansion generally occurs only at the beginning of words, but an exception based on historical practice has been
included:</p>

<pre>
<tt>PATH=/posix/bin:&#152;dgk/bin
</tt>
</pre>

<p>This is eligible for tilde expansion because &lt;tilde&gt; follows a &lt;colon&gt; and none of the relevant characters is
quoted. Consideration was given to prohibiting this behavior because any of the following are reasonable substitutes:</p>

<pre>
<tt>PATH=$(printf %s &#152;karels/bin : &#152;bostic/bin)
<br>
for Dir in &#152;maart/bin &#152;srb/bin ...
do
    PATH=${PATH:+$PATH:}$Dir
done
</tt>
</pre>

<p>In the first command, explicit &lt;colon&gt; characters are used for each directory. In all cases, the shell performs tilde
expansion on each directory because all are separate words to the shell.</p>

<p>Note that expressions in operands such as:</p>

<pre>
<tt>make -k mumble LIBDIR=&#152;chet/lib
</tt>
</pre>

<p>do not qualify as shell variable assignments, and tilde expansion is not performed (unless the command does so itself, which <a
href="../utilities/make.html"><i>make</i></a> does not).</p>

<p>Because of the requirement that the word is not quoted, the following are not equivalent; only the last causes tilde
expansion:</p>

<pre>
<tt>\&#152;hlj/   &#152;h\lj/   &#152;"hlj"/   &#152;hlj\/   &#152;hlj/
</tt>
</pre>

<p>In an early proposal, tilde expansion occurred following any unquoted &lt;equals-sign&gt; or &lt;colon&gt;, but this was removed
because of its complexity and to avoid breaking commands such as:</p>

<pre>
<tt>rcp hostname:&#152;marc/.profile .
</tt>
</pre>

<p>System administrators on systems where <b>//</b> has an implementation-defined meaning which is different to <b>/</b>, should
not create users with a home directory of <b>/</b> or <b>//</b>, since this may lead to unexpected filename resolution on those
systems.</p>

<p>A suggestion was made that the special sequence <tt>"$&#152;"</tt> should be allowed to force tilde expansion anywhere. Since
this is not historical practice, it has been left for future implementations to evaluate. (The description in XCU <a href=
"../utilities/V3_chap02.html#tag_18_02"><i>Quoting</i></a> requires that a &lt;dollar-sign&gt; be quoted to represent itself, so
the <tt>"$&#152;"</tt> combination is already unspecified.)</p>

<p>The results of giving &lt;tilde&gt; with an unknown login name are undefined because the KornShell <tt>"&#152;+"</tt> and
<tt>"&#152;-"</tt> constructs make use of this condition, but in general it is an error to give an incorrect login name with
&lt;tilde&gt;. The results of having <i>HOME</i> unset are unspecified because some historical shells treat this as an error.</p>

<p>Historically, the Korn shell performed field splitting and pathname expansion on the results of tilde expansion, and earlier
versions of this standard reflected this. However, tilde expansion results in a pathname, and performing field splitting and
pathname expansion on something that is already a pathname is at best redundant and at worst will change the value from the correct
pathname to one or more incorrect ones. Later versions of the Korn shell do not perform these expansions and POSIX.1-2017 has been
updated to match. Note that although pathname expansion is not performed on the results of tilde expansion, this does not prevent
other parts of the same word from being expanded. For example, &#152;/a* expands to all files in <b>$HOME</b> beginning with
<tt>'a'</tt>.</p>

<h5><a name="tag_23_02_06_02"></a>Parameter Expansion</h5>

<p>The rule for finding the closing <tt>'}'</tt> in <tt>"${...}"</tt> is the one used in the KornShell and is upwardly-compatible
with the Bourne shell, which does not determine the closing <tt>'}'</tt> until the word is expanded. The advantage of this is that
incomplete expansions, such as:</p>

<pre>
<tt>${foo
</tt>
</pre>

<p>can be determined during tokenization, rather than during expansion.</p>

<p>For rationale regarding expansion of <tt>"${...}"</tt> within double-quotes, see <a href="#tag_23_02_02_03">Double-Quotes</a>
.</p>

<p>The string length and substring capabilities were included because of the demonstrated need for them, based on their usage in
other shells, such as C shell and KornShell.</p>

<p>Historical versions of the KornShell have not performed tilde expansion on the word part of parameter expansion; however, it is
more consistent to do so.</p>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0004 [458], XCU/TC1-2008/0005 [458], XCU/TC1-2008/0006 [457],
XCU/TC1-2008/0007 [457], XCU/TC1-2008/0008 [417], XCU/TC1-2008/0009 [457], XCU/TC1-2008/0010 [457], XCU/TC1-2008/0011 [457],
XCU/TC1-2008/0012 [457], XCU/TC1-2008/0013 [457], XCU/TC1-2008/0014 [457], XCU/TC1-2008/0015 [457], XCU/TC1-2008/0016 [457],
XCU/TC1-2008/0017 [457], and XCU/TC1-2008/0018 [458] are applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0013 [888] and XCU/TC2-2008/0014 [867] are applied.</p>

<h5><a name="tag_23_02_06_03"></a>Command Substitution</h5>

<p>The <tt>"$()"</tt> form of command substitution solves a problem of inconsistent behavior when using backquotes. For
example:</p>

<center>
<table border="1" cellpadding="3" align="center">
<tr valign="top">
<th align="center">
<p class="tent"><b>Command</b></p>
</th>
<th align="center">
<p class="tent"><b>Output</b></p>
</th>
</tr>

<tr valign="top">
<td align="left">
<p class="tent">echo '\$x'</p>
</td>
<td align="left">
<p class="tent">\$x</p>
</td>
</tr>

<tr valign="top">
<td align="left">
<p class="tent">echo `echo '\$x'`</p>
</td>
<td align="left">
<p class="tent">$x</p>
</td>
</tr>

<tr valign="top">
<td align="left">
<p class="tent">echo $(echo '\$x')</p>
</td>
<td align="left">
<p class="tent">\$x</p>
</td>
</tr>
</table>
</center>

<p>Additionally, the backquoted syntax has historical restrictions on the contents of the embedded command. While the newer
<tt>"$()"</tt> form can process any kind of valid embedded script, the backquoted form cannot handle some valid scripts that
include backquotes. For example, these otherwise valid embedded scripts do not work in the left column, but do work on the
right:</p>

<pre>
<tt>echo `                         echo $(
cat &lt;&lt;\eof                     cat &lt;&lt;\eof
a here-doc with `              a here-doc with )
eof                            eof
`                              )
<br>
echo `                         echo $(
echo abc # a comment with `    echo abc # a comment with )
`                              )
<br>
echo `                         echo $(
echo '`'                       echo ')'
`                              )
</tt>
</pre>

<p>Because of these inconsistent behaviors, the backquoted variety of command substitution is not recommended for new applications
that nest command substitutions or attempt to embed complex scripts.</p>

<p>The KornShell feature:</p>

<blockquote>If <i>command</i> is of the form &lt; <i>word</i>, <i>word</i> is expanded to generate a pathname, and the value of the
command substitution is the contents of this file with any trailing &lt;newline&gt; characters deleted.</blockquote>

<p>was omitted from the Shell and Utilities volume of POSIX.1-2017 because $(<a href="../utilities/cat.html"><i>cat</i></a>
<i>word</i>) is an appropriate substitute. However, to prevent breaking numerous scripts relying on this feature, it is unspecified
to have a script within <tt>"$()"</tt> that has only redirections.</p>

<p>Arithmetic expansions have precedence over command substitutions. That is, if the shell can parse an expansion beginning with
<tt>"$(("</tt> as an arithmetic expansion then it will do so. It will only parse the expansion as a command substitution (that
starts with a subshell) if it determines that it cannot parse the expansion as an arithmetic expansion. If the syntax is valid for
neither type of expansion, then it is unspecified what kind of syntax error the shell reports.</p>

<p>How well the shell performs this determination is a quality of implementation issue. Current shell implementations use
heuristics. In particular, the shell need not evaluate nested expansions when determining whether it can parse an expansion
beginning with <tt>"$(("</tt> as an arithmetic expansion. For example:</p>

<pre>
<tt>$((a $op b))
</tt>
</pre>

<p>is always an arithmetic expansion if <tt>"$op"</tt> expands to, say, <tt>'+'</tt>, but if <tt>"$op"</tt> expands to
<tt>'('</tt> then the shell might still parse the expansion as an arithmetic expansion (resulting in a syntax error due to
unbalanced parentheses) or it might perform a command substitution.</p>

<p>This standard requires that conforming applications always separate the <tt>"$("</tt> and <tt>'('</tt> with white space when a
command substitution starts with a subshell. This is because implementations may support extensions in arithmetic expressions which
could result in the shell parsing the input as an arithmetic expansion even though a minimally conforming shell would not. For
example, many shells support arrays with the array index (which can be an expression) in square brackets. Therefore, the presence
of <tt>"myfile[0-9]"</tt> within an expansion beginning <tt>"$(("</tt> is no guarantee that it will be parsed as a command
substitution.</p>

<p>The ambiguity is not restricted to the simple case of a single subshell. More complicated ambiguous cases are possible (even
with just the standard shell syntax), such as:</p>

<pre>
<tt>$(( cat &lt;&lt;EOH
+ ( (
EOH
) &amp;&amp; ( cat &lt;&lt;EOH
) ) + 1 +
EOH
))
</tt>
</pre>

<p>This can be parsed as an arithmetic expansion, with <i>cat</i> and <i>EOH</i> as the names of shell variables. Ambiguous cases
also exist where the end of the expansion is at a different location for the arithmetic expansion and the command substitution:</p>

<pre>
<tt>$((cat &lt;&lt;EOF
+((((
EOF
) &amp;&amp; (
cat &lt;&lt;EOF
+
EOF
))
</tt>
</pre>

<p>This is an incomplete arithmetic expansion, but would have been a (complete) command substitution if it could not have been
parsed as an arithmetic expansion. If this expansion occurs at the end of input then the shell reports a syntax error; it does not
parse it as a command substitution.</p>

<p>IEEE&nbsp;Std&nbsp;1003.1-2001/Cor&nbsp;1-2002, item XCU/TC1/D6/4 is applied, changing the text from: &quot;If a command
substitution occurs inside double-quotes, it shall not be performed on the results of the substitution.&quot; to: &quot;If a command
substitution occurs inside double-quotes, field splitting and pathname expansion shall not be performed on the results of the
substitution.&quot;. The replacement text taken from the ISO&nbsp;POSIX-2:1993 standard is clearer about the items that are not
performed.</p>

<p>SD5-XCU-ERN-84 is applied, clarifying how the search for the matching backquote is satisfied.</p>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0019 [217] is applied.</p>

<h5><a name="tag_23_02_06_04"></a>Arithmetic Expansion</h5>

<p>The standard developers agreed that there was a strong desire for some kind of arithmetic evaluator to provide functionality
similar to <a href="../utilities/expr.html"><i>expr</i></a>, that relating it to <tt>'$'</tt> makes it work well with the standard
shell language and provides access to arithmetic evaluation in places where accessing a utility would be inconvenient.</p>

<p>The syntax and semantics for arithmetic were revised for the ISO/IEC&nbsp;9945-2:1993 standard. The language represents a simple
subset of the previous arithmetic language (which was derived from the KornShell <tt>"(())"</tt> construct). The syntax was changed
from that of a command denoted by ((<i>expression</i>)) to an expansion denoted by $((<i>expression</i>)). The new form is a dollar
expansion ( <tt>'$'</tt> ) that evaluates the expression and substitutes the resulting value. Objections to the previous style of
arithmetic included that it was too complicated, did not fit in well with the use of variables in the shell, and its syntax
conflicted with subshells. The justification for the new syntax is that the shell is traditionally a macro language, and if a new
feature is to be added, it should be accomplished by extending the capabilities presented by the current model of the shell, rather
than by inventing a new one outside the model; adding a new dollar expansion was perceived to be the most intuitive and least
destructive way to add such a new capability.</p>

<p>The standard requires assignment operators to be supported (as listed in XCU <a href=
"../utilities/V3_chap01.html#tag_17_01_02"><i>Concepts Derived from the ISO C Standard</i></a>), and since arithmetic expansions
are not specified to be evaluated in a subshell environment, changes to variables there have to be in effect after the arithmetic
expansion, just as in the parameter expansion <tt>"${x=value}"</tt>.</p>

<p>Note, however, that <tt>"$((&nbsp;x=5&nbsp;))"</tt> need not be equivalent to <tt>"$((&nbsp;$x=5&nbsp;))"</tt>. If the value of
the environment variable <i>x</i> is the string <tt>"y="</tt>, the expansion of <tt>"$((&nbsp;x=5&nbsp;))"</tt> would set <i>x</i>
to 5 and output 5, but <tt>"$((&nbsp;$x=5&nbsp;))"</tt> would output 0 if the value of the environment variable <i>y</i> is not 5
and would output 1 if the environment variable <i>y</i> is 5. Similarly, if the value of the environment variable is 4, the
expansion of <tt>"$((&nbsp;x=5&nbsp;))"</tt> would still set <i>x</i> to 5 and output 5, but <tt>"$((&nbsp;$x=5&nbsp;))"</tt>
(which would be equivalent to <tt>"$((&nbsp;4=5&nbsp;))"</tt> ) would yield a syntax error.</p>

<p>In early proposals, a form $[<i>expression</i>] was used. It was functionally equivalent to the <tt>"$(())"</tt> of the current
text, but objections were lodged that the 1988 KornShell had already implemented <tt>"$(())"</tt> and there was no compelling
reason to invent yet another syntax. Furthermore, the <tt>"$[]"</tt> syntax had a minor incompatibility involving the patterns in
<b>case</b> statements.</p>

<p>The portion of the ISO&nbsp;C standard arithmetic operations selected corresponds to the operations historically supported in
the KornShell. In addition to the exceptions listed in XCU <a href="../utilities/V3_chap02.html#tag_18_06_04"><i>Arithmetic
Expansion</i></a>, the use of the following are explicitly outside the scope of the rules defined in XCU <a href=
"../utilities/V3_chap01.html#tag_17_01_02_01"><i>Arithmetic Precision and Operations</i></a> :</p>

<ul>
<li>
<p>The prefix operator <tt>'&amp;'</tt> and the <tt>"[]"</tt>, <tt>"-&gt;"</tt>, and <tt>'.'</tt> operators.</p>
</li>

<li>
<p>Casts</p>
</li>
</ul>

<p>It was concluded that the <a href="../utilities/test.html"><i>test</i></a> command (<b>[</b>) was sufficient for the majority
of relational arithmetic tests, and that tests involving complicated relational expressions within the shell are rare, yet could
still be accommodated by testing the value of <tt>"$(())"</tt> itself. For example:</p>

<pre>
<tt># a complicated relational expression
while [ $(( (($x + $y)/($a * $b)) &lt; ($foo*$bar) )) -ne 0 ]
</tt>
</pre>

<p>or better yet, the rare script that has many complex relational expressions could define a function like this:</p>

<pre>
<tt>val() {
    return $((!$1))
}
</tt>
</pre>

<p>and complicated tests would be less intimidating:</p>

<pre>
<tt>while val $(( (($x + $y)/($a * $b)) &lt; ($foo*$bar) ))
do
    # some calculations
done
</tt>
</pre>

<p>A suggestion that was not adopted was to modify <a href="../utilities/true.html"><i>true</i></a> and <a href=
"../utilities/false.html"><i>false</i></a> to take an optional argument, and <a href="../utilities/true.html"><i>true</i></a> would
exit true only if the argument was non-zero, and <a href="../utilities/false.html"><i>false</i></a> would exit false only if the
argument was non-zero:</p>

<pre>
<tt>while true $(($x &gt; 5 &amp;&amp; $y &lt;= 25))
</tt>
</pre>

<p>There is a minor portability concern with the new syntax. The example <tt>"$((2+2))"</tt> could have been intended to mean a
command substitution of a utility named <tt>"2+2"</tt> in a subshell. The standard developers considered this to be obscure and
isolated to some KornShell scripts (because <tt>"$()"</tt> command substitution existed previously only in the KornShell). The text
on command substitution requires that the <tt>"$("</tt> and <tt>'('</tt> be separate tokens if this usage is needed.</p>

<p>An example such as:</p>

<pre>
<tt>echo $((echo hi);(echo there))
</tt>
</pre>

<p>should not be misinterpreted by the shell as arithmetic because attempts to balance the parentheses pairs would indicate that
they are subshells. However, as indicated by XBD <a href="../basedefs/V1_chap03.html#tag_03_113"><i>Control Operator</i></a>, a
conforming application must separate two adjacent parentheses with white space to indicate nested subshells.</p>

<p>The standard is intentionally silent about how a variable's numeric value in an expression is determined from its normal
&quot;sequence of bytes&quot; value. It could be done as a text substitution, as a conversion like that performed by <a href=
"../functions/strtol.html"><i>strtol</i>()</a>, or even recursive evaluation. Therefore, the only cases for which the standard is
clear are those for which both conversions produce the same result. The cases where they give the same result are those where the
sequence of bytes form a valid integer constant. Therefore, if a variable does not contain a valid integer constant, the behavior
is unspecified.</p>

<p>For the commands:</p>

<pre>
<tt>x=010; echo $((x += 1))
</tt>
</pre>

<p>the output must be 9.</p>

<p>For the commands:</p>

<pre>
<tt>x=' 1'; echo $((x += 1))
</tt>
</pre>

<p>the results are unspecified.</p>

<p>For the commands:</p>

<pre>
<tt>x=1+1; echo $((x += 1))
</tt>
</pre>

the results are unspecified. 

<p>Although the ISO/IEC&nbsp;9899:1999 standard now requires support for <b>long long</b> and allows extended integer types with
higher ranks, POSIX.1-2017 only requires arithmetic expansions to support <b>signed long</b> integer arithmetic. Implementations
are encouraged to support signed integer values at least as large as the size of the largest file allowed on the
implementation.</p>

<p>Implementations are also allowed to perform floating-point evaluations as long as an application won't see different results for
expressions that would not overflow <b>signed long</b> integer expression evaluation. (This includes appropriate truncation of
results to integer values.)</p>

<p>Changes made in response to IEEE PASC Interpretation 1003.2 #208 removed the requirement that the integer constant suffixes
<tt>l</tt> and <tt>L</tt> had to be recognized. The ISO&nbsp;POSIX-2:1993 standard did not require the <tt>u</tt>, <tt>ul</tt>,
<tt>uL</tt>, <tt>U</tt>, <tt>Ul</tt>, <tt>UL</tt>, <tt>lu</tt>, <tt>lU</tt>, <tt>Lu</tt>, and <tt>LU</tt> suffixes since
only signed integer arithmetic was required. Since all arithmetic expressions were treated as handling <b>signed long</b> integer
types anyway, the <tt>l</tt> and <tt>L</tt> suffixes were redundant. No known scripts used them and some historic shells did not
support them. When the ISO/IEC&nbsp;9899:1999 standard was used as the basis for the description of arithmetic processing, the
<tt>ll</tt> and <tt>LL</tt> suffixes and combinations were also not required. Implementations are still free to accept any or all
of these suffixes, but are not required to do so.</p>

<p>There was also some confusion as to whether the shell was required to recognize character constants. Syntactically, character
constants were required to be recognized, but the requirements for the handling of &lt;backslash&gt; and single-quote characters
(needed to specify character constants) within an arithmetic expansion were ambiguous. Furthermore, no known shells supported them.
Changes made in response to IEEE PASC Interpretation 1003.2 #208 removed the requirement to support them (if they were indeed
required before). POSIX.1-2017 clearly does not require support for character constants.</p>

<p>IEEE&nbsp;Std&nbsp;1003.1-2001/Cor&nbsp;2-2004, item XCU/TC2/D6/3 is applied, clarifying arithmetic expressions.</p>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0020 [50] is applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0015 [584] is applied.</p>

<h5><a name="tag_23_02_06_05"></a>Field Splitting</h5>

<p>The operation of field splitting using <i>IFS,</i> as described in early proposals, was based on the way the KornShell splits
words, but it is incompatible with other common versions of the shell. However, each has merit, and so a decision was made to allow
both. If the <i>IFS</i> variable is unset or is &lt;space&gt; &lt;tab&gt; &lt;newline&gt;, the operation is equivalent to the way
the System&nbsp;V shell splits words. Using characters outside the &lt;space&gt; &lt;tab&gt; &lt;newline&gt; set yields the
KornShell behavior, where each of the non- &lt;space&gt; &lt;tab&gt; &lt;newline&gt;s is significant. This behavior, which affords
the most flexibility, was taken from the way the original <a href="../utilities/awk.html"><i>awk</i></a> handled field
splitting.</p>

<p>Rule (3) can be summarized as a pseudo-ERE:</p>

<pre>
<tt>(</tt><i>s</i><tt>*</tt><i>ns</i><tt>*|</tt><i>s</i><tt>+)
</tt>
</pre>

<p>where <i>s</i> is an <i>IFS</i> white-space character and <i>n</i> is a character in the <i>IFS</i> that is not white space. Any
string matching that ERE delimits a field, except that the <i>s</i>+ form does not delimit fields at the beginning or the end of a
line. For example, if <i>IFS</i> is &lt;space&gt;/ &lt;comma&gt;/ &lt;tab&gt;, the string:</p>

<pre>
<tt>&lt;space&gt;&lt;space&gt;red&lt;space&gt;&lt;space&gt;,&lt;space&gt;white&lt;space&gt;blue
</tt>
</pre>

<p>yields the three colors as the delimited fields.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0016 [832] is applied.</p>

<h5><a name="tag_23_02_06_06"></a>Pathname Expansion</h5>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_23_02_06_07"></a>Quote Removal</h5>

<p>There is no additional rationale provided for this section.</p>

<h4><a name="tag_23_02_07">  C.2.7  </a>Redirection</h4>

<p>In the System Interfaces volume of POSIX.1-2017, file descriptors are integers in the range 0-({OPEN_MAX}-1). The file
descriptors discussed in XCU <a href="../utilities/V3_chap02.html#tag_18_07"><i>Redirection</i></a> are that same set of small
integers.</p>

<p>Having multi-digit file descriptor numbers for I/O redirection can cause some obscure compatibility problems. Specifically,
scripts that depend on an example command:</p>

<pre>
<tt>echo 22&gt;/dev/null
</tt>
</pre>

<p>echoing <tt>"2"</tt> to standard error or <tt>"22"</tt> to standard output are no longer portable. However, the file descriptor
number must still be delimited from the preceding text. For example:</p>

<pre>
<tt>cat file2&gt;foo
</tt>
</pre>

<p>writes the contents of <b>file2</b>, not the contents of <b>file</b>.</p>

<p>The <tt>"&gt;|"</tt> format of output redirection was adopted from the KornShell. Along with the <i>noclobber</i> option, <a
href="../utilities/V4_xcu_chap02.html#set"><i>set</i></a> <b>-C</b>, it provides a safety feature to prevent inadvertent
overwriting of existing files. (See the RATIONALE for the <a href="../utilities/pathchk.html"><i>pathchk</i></a> utility for why
this step was taken.) The restriction on regular files is historical practice.</p>

<p>The System&nbsp;V shell and the KornShell have differed historically on pathname expansion of <i>word</i>; the former never
performed it, the latter only when the result was a single field (file). As a compromise, it was decided that the KornShell
functionality was useful, but only as a shorthand device for interactive users. No reasonable shell script would be written with a
command such as:</p>

<pre>
<tt>cat foo &gt; a*
</tt>
</pre>

<p>Thus, shell scripts are prohibited from doing it, while interactive users can select the shell with which they are most
comfortable.</p>

<p>The construct <tt>"2&gt;&amp;1"</tt> is often used to redirect standard error to the same file as standard output. Since the
redirections take place beginning to end, the order of redirections is significant. For example:</p>

<pre>
<tt>ls &gt; foo 2&gt;&amp;1
</tt>
</pre>

<p>directs both standard output and standard error to file <b>foo</b>. However:</p>

<pre>
<tt>ls 2&gt;&amp;1 &gt; foo
</tt>
</pre>

<p>only directs standard output to file <b>foo</b> because standard error was duplicated as standard output before standard output
was directed to file <b>foo</b>.</p>

<p>Applications should not use the <b>[</b><i>n</i><b>]</b><tt>&lt;&amp;-</tt> or <b>[</b><i>n</i><b>]</b><tt>&gt;&amp;-</tt>
operators to execute a utility or application with file descriptor 0 not open for reading or with file descriptor 1 or 2 not open
for writing, as this might cause the executed program (or shell built-in) to misbehave. In order not to pass on these file
descriptors to an executed utility or application, applications should not just close them but should reopen them on, for example,
<b>/dev/null</b>. Some implementations may reopen them automatically, but applications should not rely on this being done.</p>

<p>The <tt>"&lt;&gt;"</tt> operator could be useful in writing an application that worked with several terminals, and occasionally
wanted to start up a shell. That shell would in turn be unable to run applications that run from an ordinary controlling terminal
unless it could make use of <tt>"&lt;&gt;"</tt> redirection. The specific example is a historical version of the pager <a href=
"../utilities/more.html"><i>more</i></a>, which reads from standard error to get its commands, so standard input and standard
output are both available for their usual usage. There is no way of saying the following in the shell without <tt>"&lt;&gt;"</tt>
:</p>

<pre>
<tt>cat food | more - &gt;/dev/tty03 2&lt;&gt;/dev/tty03
</tt>
</pre>

<p>Another example of <tt>"&lt;&gt;"</tt> is one that opens <b>/dev/tty</b> on file descriptor 3 for reading and writing:</p>

<pre>
<tt>exec 3&lt;&gt; /dev/tty
</tt>
</pre>

<p>An example of creating a lock file for a critical code region:</p>

<pre>
<tt>set -C
until    2&gt; /dev/null &gt; lockfile
do       sleep 30
done
set +C
</tt><i>perform critical function</i><tt>rm lockfile
</tt>
</pre>

<p>Since <b>/dev/null</b> is not a regular file, no error is generated by redirecting to it in <i>noclobber</i> mode.</p>

<p>Tilde expansion is not performed on a here-document because the data is treated as if it were enclosed in double-quotes.</p>

<h5><a name="tag_23_02_07_01"></a>Redirecting Input</h5>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_23_02_07_02"></a>Redirecting Output</h5>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_23_02_07_03"></a>Appending Redirected Output</h5>

<p>Note that when a file is opened (even with the O_APPEND flag set), the initial file offset for that file is set to the beginning
of the file. Some historic shells set the file offset to the current end-of-file when <b>append</b> mode shell redirection was
used, but this is not allowed by POSIX.1-2017.</p>

<h5><a name="tag_23_02_07_04"></a>Here-Document</h5>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0017 [890], XCU/TC2-2008/0018 [583], and XCU/TC2-2008/0019 [580] are
applied.</p>

<h5><a name="tag_23_02_07_05"></a>Duplicating an Input File Descriptor</h5>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_23_02_07_06"></a>Duplicating an Output File Descriptor</h5>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_23_02_07_07"></a>Open File Descriptors for Reading and Writing</h5>

<p>There is no additional rationale provided for this section.</p>

<h4><a name="tag_23_02_08">  C.2.8  </a>Exit Status and Errors</h4>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_23_02_08_01"></a>Consequences of Shell Errors</h5>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0020 [882] and XCU/TC2-2008/0021 [717,882] are applied.</p>

<h5><a name="tag_23_02_08_02"></a>Exit Status for Commands</h5>

<p>There is a historical difference in <a href="../utilities/sh.html"><i>sh</i></a> and <i>ksh</i> non-interactive error behavior.
When a command named in a script is not found, some implementations of <a href="../utilities/sh.html"><i>sh</i></a> exit
immediately, but <i>ksh</i> continues with the next command. Thus, the Shell and Utilities volume of POSIX.1-2017 says that the
shell &quot;may&quot; exit in this case. This puts a small burden on the programmer, who has to test for successful completion following a
command if it is important that the next command not be executed if the previous command was not found. If it is important for the
command to have been found, it was probably also important for it to complete successfully. The test for successful completion
would not need to change.</p>

<p>Historically, shells have returned an exit status of 128+ <i>n</i>, where <i>n</i> represents the signal number. Since signal
numbers are not standardized, there is no portable way to determine which signal caused the termination. Also, it is possible for a
command to exit with a status in the same range of numbers that the shell would use to report that the command was terminated by a
signal. Implementations are encouraged to choose exit values greater than 256 to indicate programs that terminate by a signal so
that the exit status cannot be confused with an exit status generated by a normal termination.</p>

<p>Historical shells make the distinction between &quot;utility not found&quot; and &quot;utility found but cannot execute&quot; in their error
messages. By specifying two seldomly used exit status values for these cases, 127 and 126 respectively, this gives an application
the opportunity to make use of this distinction without having to parse an error message that would probably change from locale to
locale. The <a href="../utilities/command.html"><i>command</i></a>, <a href="../utilities/env.html"><i>env</i></a>, <a href=
"../utilities/nohup.html"><i>nohup</i></a>, and <a href="../utilities/xargs.html"><i>xargs</i></a> utilities in the Shell and
Utilities volume of POSIX.1-2017 have also been specified to use this convention.</p>

<p>When a command fails during word expansion or redirection, most historical implementations exit with a status of 1. However,
there was some sentiment that this value should probably be much higher so that an application could distinguish this case from the
more normal exit status values. Thus, the language &quot;greater than zero&quot; was selected to allow either method to be implemented.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0022 [717] is applied.</p>

<h4><a name="tag_23_02_09">  C.2.9  </a>Shell Commands</h4>

<p>A description of an &quot;empty command&quot; was removed from an early proposal because it is only relevant in the cases of <a href=
"../utilities/sh.html"><i>sh</i></a> <b>-c</b> <tt>""</tt>, <i>system</i>( <tt>""</tt> ), or an empty shell-script file (such as
the implementation of <a href="../utilities/true.html"><i>true</i></a> on some historical systems). Since it is no longer mentioned
in the Shell and Utilities volume of POSIX.1-2017, it falls into the silently unspecified category of behavior where
implementations can continue to operate as they have historically, but conforming applications do not construct empty commands.
(However, note that <a href="../utilities/sh.html"><i>sh</i></a> does explicitly state an exit status for an empty string or file.)
In an interactive session or a script with other commands, extra &lt;newline&gt; or &lt;semicolon&gt; characters, such as:</p>

<pre>
<tt>$ false
$
$ echo $?
1
</tt>
</pre>

<p>would not qualify as the empty command described here because they would be consumed by other parts of the grammar.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0023 [473] is applied.</p>

<h5><a name="tag_23_02_09_01"></a>Simple Commands</h5>

<p>The enumerated list is used only when the command is actually going to be executed. For example, in:</p>

<pre>
<tt>true || $foo *
</tt>
</pre>

<p>no expansions are performed.</p>

<p>The following example illustrates both how a variable assignment without a command name affects the current execution
environment, and how an assignment with a command name only affects the execution environment of the command:</p>

<pre>
<b>$</b> <tt>x=red
</tt><b>$</b> <tt>echo $x
</tt><b>red
$</b> <tt>export x
</tt><b>$</b> <tt>sh -c 'echo $x'
</tt><b>red
$</b> <tt>x=blue sh -c 'echo $x'
</tt><b>blue
$</b> <tt>echo $x
</tt><b>red</b>
</pre>

<p>This next example illustrates that redirections without a command name are still performed:</p>

<pre>
<b>$</b> <tt>ls foo
</tt><b>ls: foo: no such file or directory
$</b> <tt>&gt; foo
</tt><b>$</b> <tt>ls foo
</tt><b>foo</b>
</pre>

<br>
<p>A command without a command name, but one that includes a command substitution, has an exit status of the last command
substitution that the shell performed. For example:</p>

<pre>
<tt>if      x=$(</tt><i>command</i><tt>)
then    ...
fi
</tt>
</pre>

<p>An example of redirections without a command name being performed in a subshell shows that the here-document does not disrupt
the standard input of the <b>while</b> loop:</p>

<pre>
<tt>IFS=:
while    read a b
do       echo $a
         &lt;&lt;-eof
         Hello
         eof
done &lt;/etc/passwd
</tt>
</pre>

<p>Following are examples of commands without command names in AND-OR lists:</p>

<pre>
<tt>&gt; foo || {
    echo "error: foo cannot be created" &gt;&amp;2
    exit 1
}
<br>
# set saved if /vmunix.save exists
test -f /vmunix.save &amp;&amp; saved=1
</tt>
</pre>

<p>Command substitution and redirections without command names both occur in subshells, but they are not necessarily the same ones.
For example, in:</p>

<pre>
<tt>exec 3&gt; file
var=$(echo foo &gt;&amp;3) 3&gt;&amp;1
</tt>
</pre>

<p>it is unspecified whether <b>foo</b> is echoed to the file or to standard output.</p>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0021 [255] is applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0024 [654] is applied.</p>

<h5><a name="tag_23_02_09_02"></a>Command Search and Execution</h5>

<p>This description requires that the shell can execute shell scripts directly, even if the underlying system does not support the
common <tt>"#!"</tt> interpreter convention. That is, if file <b>foo</b> contains shell commands and is executable, the following
executes <b>foo</b>:</p>

<pre>
<tt>./foo
</tt>
</pre>

<p>The command search shown here does not match all historical implementations. A more typical sequence has been:</p>

<ul>
<li>
<p>Any built-in (special or regular)</p>
</li>

<li>
<p>Functions</p>
</li>

<li>
<p>Path search for executable files</p>
</li>
</ul>

<p>But there are problems with this sequence. Since the programmer has no idea in advance which utilities might have been built
into the shell, a function cannot be used to override portably a utility of the same name. (For example, a function named <a href=
"../utilities/cd.html"><i>cd</i></a> cannot be written for many historical systems.) Furthermore, the <i>PATH</i> variable is
partially ineffective in this case, and only a pathname with a &lt;slash&gt; can be used to ensure a specific executable file is
invoked.</p>

<p>After the <a href="../functions/execve.html"><i>execve</i>()</a> failure described, the shell normally executes the file as a
shell script. Some implementations, however, attempt to detect whether the file is actually a script and not an executable from
some other architecture. The method used by the KornShell is allowed by the text that indicates non-text files may be bypassed.</p>

<p>The sequence selected for the Shell and Utilities volume of POSIX.1-2017 acknowledges that special built-ins cannot be
overridden, but gives the programmer full control over which versions of other utilities are executed. It provides a means of
suppressing function lookup (via the <a href="../utilities/command.html"><i>command</i></a> utility) for the user's own functions
and ensures that any regular built-ins or functions provided by the implementation are under the control of the path search. The
mechanisms for associating built-ins or functions with executable files in the path are not specified by the Shell and Utilities
volume of POSIX.1-2017, but the wording requires that if either is implemented, the application is not able to distinguish a
function or built-in from an executable (other than in terms of performance, presumably). The implementation ensures that all
effects specified by the Shell and Utilities volume of POSIX.1-2017 resulting from the invocation of the regular built-in or
function (interaction with the environment, variables, traps, and so on) are identical to those resulting from the invocation of an
executable file.</p>

<p>Various historical implementations have used the names in item 1.b. as built-ins or reserved words. This standard does not
specify their behavior, but their existence means that it is important for portable applications to avoid giving functions (or
utilities in <i>PATH)</i> those names because the function (or utility in <i>PATH)</i> might not be executed as expected.</p>

<p>IEEE&nbsp;Std&nbsp;1003.1-2001/Cor&nbsp;2-2004, item XCU/TC2/D6/4 is applied, updating the case where <a href=
"../functions/execve.html"><i>execve</i>()</a> fails due to an error equivalent to the [ENOEXEC] error.</p>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0022 [168], XCU/TC1-2008/0023 [168], XCU/TC1-2008/0024 [168],
XCU/TC1-2008/0025 [168], XCU/TC1-2008/0026 [168,430], XCU/TC1-2008/0027 [168,430], and XCU/TC1-2008/0028 [173] are applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0025 [935] and XCU/TC2-2008/0026 [705] are applied.</p>

<h5><a name="tag_23_02_09_03"></a>Examples</h5>

<p>Consider three versions of the <a href="../utilities/ls.html"><i>ls</i></a> utility:</p>

<ol>
<li>
<p>The application includes a shell function named <a href="../utilities/ls.html"><i>ls</i></a>.</p>
</li>

<li>
<p>The user writes a utility named <a href="../utilities/ls.html"><i>ls</i></a> and puts it in <b>/fred/bin</b>.</p>
</li>

<li>
<p>The example implementation provides <a href="../utilities/ls.html"><i>ls</i></a> as a regular shell built-in that is invoked
(either by the shell or directly by <i>exec</i>) when the path search reaches the directory <b>/posix/bin</b>.</p>
</li>
</ol>

<p>If <i>PATH =</i> <b>/posix/bin</b>, various invocations yield different versions of <a href=
"../utilities/ls.html"><i>ls</i></a>:</p>

<center>
<table border="1" cellpadding="3" align="center">
<tr valign="top">
<th align="center">
<p class="tent"><b>Invocation</b></p>
</th>
<th align="center">
<p class="tent"><b>Version of <i>ls</i></b></p>
</th>
</tr>

<tr valign="top">
<td align="left">
<p class="tent"><i>ls</i> (from within application script)</p>
</td>
<td align="left">
<p class="tent">(1) function</p>
</td>
</tr>

<tr valign="top">
<td align="left">
<p class="tent"><i>command ls</i> (from within application script)</p>
</td>
<td align="left">
<p class="tent">(3) built-in</p>
</td>
</tr>

<tr valign="top">
<td align="left">
<p class="tent"><i>ls</i> (from within makefile called by application)</p>
</td>
<td align="left">
<p class="tent">(3) built-in</p>
</td>
</tr>

<tr valign="top">
<td align="left">
<p class="tent"><i>system</i>("<i>ls</i>")</p>
</td>
<td align="left">
<p class="tent">(3) built-in</p>
</td>
</tr>

<tr valign="top">
<td align="left">
<p class="tent"><i>PATH</i>="<b>/fred/bin</b>:$<i>PATH</i>" <i>ls</i></p>
</td>
<td align="left">
<p class="tent">(2) user's version</p>
</td>
</tr>
</table>
</center>

<h5><a name="tag_23_02_09_04"></a>Pipelines</h5>

<p>Because pipeline assignment of standard input or standard output or both takes place before redirection, it can be modified by
redirection. For example:</p>

<pre>
<b>$</b> <i>command1</i> <tt>2&gt;&amp;1 |</tt> <i>command2</i>
</pre>

<p>sends both the standard output and standard error of <i>command1</i> to the standard input of <i>command2</i>.</p>

<p>The reserved word <b>!</b> allows more flexible testing using AND and OR lists. The behavior of <b>!(</b> is unspecified because
in the Korn Shell this introduces a negated pathname expansion. Portable applications need to separate the <b>!</b> and <b>(</b> to
ensure the command is treated as a negated subshell.</p>

<p>It was suggested that it would be better to return a non-zero value if any command in the pipeline terminates with non-zero
status (perhaps the bitwise-inclusive OR of all return values). However, the choice of the last-specified command semantics are
historical practice and would cause applications to break if changed. An example of historical behavior:</p>

<pre>
<tt>$ sleep 5 | (exit 4)
$ echo $?
4
$ (exit 4) | sleep 5
$ echo $?
0
</tt>
</pre>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0029 [205] is applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0027 [521] is applied.</p>

<h5><a name="tag_23_02_09_05"></a>Exit Status</h5>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0030 [52] is applied.</p>

<h5><a name="tag_23_02_09_06"></a>Lists</h5>

<p>The equal precedence of <tt>"&amp;&amp;"</tt> and <tt>"||"</tt> is historical practice. The standard developers evaluated the
model used more frequently in high-level programming languages, such as C, to allow the shell logical operators to be used for
complex expressions in an unambiguous way, but they could not allow historical scripts to break in the subtle way unequal
precedence might cause. Some arguments were posed concerning the <tt>"{}"</tt> or <tt>"()"</tt> groupings that are required
historically. There are some disadvantages to these groupings:</p>

<ul>
<li>
<p>The <tt>"()"</tt> can be expensive, as they spawn other processes on some implementations. This performance concern is primarily
an implementation issue.</p>
</li>

<li>
<p>The <tt>"{}"</tt> braces are not operators (they are reserved words) and require a trailing &lt;space&gt; after each
<tt>'{'</tt>, and a &lt;semicolon&gt; before each <tt>'}'</tt>. Most programmers (and certainly interactive users) have avoided
braces as grouping constructs because of the problematic syntax required. Braces were not changed to operators because that would
generate compatibility issues even greater than the precedence question; braces appear outside the context of a keyword in many
shell scripts.</p>
</li>
</ul>

<p>IEEE PASC Interpretation 1003.2 #204 is applied, clarifying that the operators <tt>"&amp;&amp;"</tt> and <tt>"||"</tt> are
evaluated with left associativity.</p>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0031 [45] and XCU/TC1-2008/0032 [45] are applied.</p>

<h5><a name="tag_23_02_09_07"></a>Asynchronous Lists</h5>

<p>The grammar treats a construct such as:</p>

<pre>
<tt>foo &amp; bar &amp; bam &amp;
</tt>
</pre>

<p>as one &quot;asynchronous list&quot;, but since the status of each element is tracked by the shell, the term &quot;element of an
asynchronous list&quot; was introduced to identify just one of the <b>foo</b>, <b>bar</b>, or <b>bam</b> portions of the overall
list.</p>

<p>Unless the implementation has an internal limit, such as {CHILD_MAX}, on the retained process IDs, it would require unbounded
memory for the following example:</p>

<pre>
<tt>while true
do      foo &amp; echo $!
done
</tt>
</pre>

<p>The treatment of the signals SIGINT and SIGQUIT with asynchronous lists is described in XCU <a href=
"../utilities/V3_chap02.html#tag_18_11"><i>Signals and Error Handling</i></a>.</p>

<p>Since the connection of the input to the equivalent of <b>/dev/null</b> is considered to occur before redirections, the
following script would produce no output:</p>

<pre>
<tt>exec &lt; /etc/passwd
cat &lt;&amp;0 &amp;
wait
</tt>
</pre>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0028 [760] is applied.</p>

<h5><a name="tag_23_02_09_08"></a>Sequential Lists</h5>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_23_02_09_09"></a>AND Lists</h5>

<p>There is no additional rationale provided for this section.</p>

<h5><a name="tag_23_02_09_10"></a>OR Lists</h5>

<p>There is no additional rationale provided for this section.<br>
</p>

<h5><a name="tag_23_02_09_11"></a>Compound Commands</h5>

<h5><a name="tag_23_02_09_12"></a>Grouping Commands</h5>

<p>The semicolon shown in { <i>compound-list</i>;} is an example of a control operator delimiting the <b>}</b> reserved word. Other
delimiters are possible, as shown in XCU <a href="../utilities/V3_chap02.html#tag_18_10"><i>Shell Grammar</i></a>; &lt;newline&gt;
is frequently used.</p>

<p>A proposal was made to use the <b>&lt;do-done&gt;</b> construct in all cases where command grouping in the current process
environment is performed, identifying it as a construct for the grouping commands, as well as for shell functions. This was not
included because the shell already has a grouping construct for this purpose ( <tt>"{}"</tt> ), and changing it would have been
counter-productive.</p>

<p>The requirement for conforming applications to separate two leading <tt>'('</tt> characters with white space if a grouping
command would be parsed as an arithmetic expansion if preceded by a <tt>'$'</tt> is to allow shells which implement the <tt>"((
arithmetic expression ))"</tt> extension to apply the same disambiguation rules consistently to <tt>$((...))</tt> and
<tt>((...))</tt>. See <a href="#tag_23_02_06_03">Command Substitution</a>.</p>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0033 [217] is applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0029 [473] is applied.</p>

<h5><a name="tag_23_02_09_13"></a>For Loop</h5>

<p>The format is shown with generous usage of &lt;newline&gt; characters. See the grammar in XCU <a href=
"../utilities/V3_chap02.html#tag_18_10"><i>Shell Grammar</i></a> for a precise description of where &lt;newline&gt; and
&lt;semicolon&gt; characters can be interchanged.</p>

<p>Some historical implementations support <tt>'{'</tt> and <tt>'}'</tt> as substitutes for <b>do</b> and <b>done</b>. The standard
developers chose to omit them, even as an obsolescent feature. (Note that these substitutes were only for the <b>for</b> command;
the <b>while</b> and <b>until</b> commands could not use them historically because they are followed by compound-lists that may
contain <tt>"{...}"</tt> grouping commands themselves.)</p>

<p>The reserved word pair <b>do</b>... <b>done</b> was selected rather than <b>do</b>... <b>od</b> (which would have matched the
spirit of <b>if</b>... <b>fi</b> and <b>case</b>... <b>esac</b>) because <a href="../utilities/od.html"><i>od</i></a> is already
the name of a standard utility.</p>

<p>PASC Interpretation 1003.2 #169 has been applied changing the grammar.</p>

<h5><a name="tag_23_02_09_14"></a>Case Conditional Construct</h5>

<p>An optional &lt;left-parenthesis&gt; before <i>pattern</i> was added to allow numerous historical KornShell scripts to conform.
At one time, using the leading parenthesis was required if the <b>case</b> statement was to be embedded within a <tt>"$()"</tt>
command substitution; this is no longer the case with the POSIX shell. Nevertheless, many historical scripts use the
&lt;left-parenthesis&gt;, if only because it makes matching-parenthesis searching easier in <a href=
"../utilities/vi.html"><i>vi</i></a> and other editors. This is a relatively simple implementation change that is
upwards-compatible for all scripts.</p>

<p>Consideration was given to requiring <a href="../utilities/V4_xcu_chap02.html#break"><i>break</i></a> inside the
<i>compound-list</i> to prevent falling through to the next pattern action list. This was rejected as being nonexisting practice.
An interesting undocumented feature of the KornShell is that using <tt>";&amp;"</tt> instead of <tt>";;"</tt> as a terminator
causes the exact opposite behavior-the flow of control continues with the next <i>compound-list</i>.</p>

<p>The pattern <tt>'*'</tt>, given as the last pattern in a <b>case</b> construct, is equivalent to the default case in a
C-language <b>switch</b> statement.</p>

<p>The grammar shows that reserved words can be used as patterns, even if one is the first word on a line. Obviously, the reserved
word <b>esac</b> cannot be used in this manner.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0029 [473] is applied.</p>

<h5><a name="tag_23_02_09_15"></a>If Conditional Construct</h5>

<p>The precise format for the command syntax is described in XCU <a href="../utilities/V3_chap02.html#tag_18_10"><i>Shell
Grammar</i></a>.</p>

<h5><a name="tag_23_02_09_16"></a>While Loop</h5>

<p>The precise format for the command syntax is described in XCU <a href="../utilities/V3_chap02.html#tag_18_10"><i>Shell
Grammar</i></a>.</p>

<h5><a name="tag_23_02_09_17"></a>Until Loop</h5>

<p>The precise format for the command syntax is described in XCU <a href="../utilities/V3_chap02.html#tag_18_10"><i>Shell
Grammar</i></a>.</p>

<h5><a name="tag_23_02_09_18"></a>Function Definition Command</h5>

<p>The description of functions in an early proposal was based on the notion that functions should behave like miniature shell
scripts; that is, except for sharing variables, most elements of an execution environment should behave as if they were a new
execution environment, and changes to these should be local to the function. For example, traps and options should be reset on
entry to the function, and any changes to them do not affect the traps or options of the caller. There were numerous objections to
this basic idea, and the opponents asserted that functions were intended to be a convenient mechanism for grouping common commands
that were to be executed in the current execution environment, similar to the execution of the <a href=
"../utilities/V4_xcu_chap02.html#dot"><i>dot</i></a> special built-in.</p>

<p>It was also pointed out that the functions described in that early proposal did not provide a local scope for everything a new
shell script would, such as the current working directory, or <a href="../utilities/umask.html"><i>umask</i></a>, but instead
provided a local scope for only a few select properties. The basic argument was that if a local scope is needed for the execution
environment, the mechanism already existed: the application can put the commands in a new shell script and call that script. All
historical shells that implemented functions, other than the KornShell, have implemented functions that operate in the current
execution environment. Because of this, traps and options have a global scope within a shell script. Local variables within a
function were considered and included in another early proposal (controlled by the special built-in <i>local</i>), but were removed
because they do not fit the simple model developed for functions and because there was some opposition to adding yet another new
special built-in that was not part of historical practice. Implementations should reserve the identifier <i>local</i> (as well as
<i>typeset</i>, as used in the KornShell) in case this local variable mechanism is adopted in a future version of this
standard.</p>

<p>A separate issue from the execution environment of a function is the availability of that function to child shells. A few
objectors maintained that just as a variable can be shared with child shells by exporting it, so should a function. In early
proposals, the <a href="../utilities/V4_xcu_chap02.html#export"><i>export</i></a> command therefore had a <b>-f</b> flag for
exporting functions. Functions that were exported were to be put into the environment as <i>name</i>()= <i>value</i> pairs, and
upon invocation, the shell would scan the environment for these and automatically define these functions. This facility was
strongly opposed and was omitted. Some of the arguments against exportable functions were as follows:</p>

<ul>
<li>
<p>There was little historical practice. The Ninth Edition shell provided them, but there was controversy over how well it
worked.</p>
</li>

<li>
<p>There are numerous security problems associated with functions appearing in the environment of a user and overriding standard
utilities or the utilities owned by the application.</p>
</li>

<li>
<p>There was controversy over requiring <a href="../utilities/make.html"><i>make</i></a> to import functions, where it has
historically used an <i>exec</i> function for many of its command line executions.</p>
</li>

<li>
<p>Functions can be big and the environment is of a limited size. (The counter-argument was that functions are no different from
variables in terms of size: there can be big ones, and there can be small ones-and just as one does not export huge variables, one
does not export huge functions. However, this might not apply to the average shell-function writer, who typically writes much
larger functions than variables.)</p>
</li>
</ul>

<p>As far as can be determined, the functions in the Shell and Utilities volume of POSIX.1-2017 match those in System&nbsp;V.
Earlier versions of the KornShell had two methods of defining functions:</p>

<pre>
<tt>function</tt> <i>fname</i> <tt>{</tt> <i>compound-list</i> <tt>}
</tt>
</pre>

<p>and:</p>

<pre>
<i>fname</i><tt>() {</tt> <i>compound-list</i> <tt>}
</tt>
</pre>

<p>The latter used the same definition as the Shell and Utilities volume of POSIX.1-2017, but differed in semantics, as described
previously. The current edition of the KornShell aligns the latter syntax with the Shell and Utilities volume of POSIX.1-2017 and
keeps the former as is.</p>

<p>The name space for functions is limited to that of a <i>name</i> because of historical practice. Complications in defining the
syntactic rules for the function definition command and in dealing with known extensions such as the <tt>"@()"</tt> usage in the
KornShell prevented the name space from being widened to a <i>word</i>. Using functions to support synonyms such as the
<tt>"!!"</tt> and <tt>'%'</tt> usage in the C shell is thus disallowed to conforming applications, but acceptable as an extension.
For interactive users, the aliasing facilities in the Shell and Utilities volume of POSIX.1-2017 should be adequate for this
purpose. It is recognized that the name space for utilities in the file system is wider than that currently supported for
functions, if the portable filename character set guidelines are ignored, but it did not seem useful to mandate extensions in
systems for so little benefit to conforming applications.</p>

<p>The <tt>"()"</tt> in the function definition command consists of two operators. Therefore, intermixing &lt;blank&gt; characters
with the <i>fname</i>, <tt>'('</tt>, and <tt>')'</tt> is allowed, but unnecessary.</p>

<p>An example of how a function definition can be used wherever a simple command is allowed:</p>

<pre>
<tt># If variable i is equal to "yes",
# define function foo to be ls -l
#
[ "$i" = yes ] &amp;&amp; foo() {
    ls -l
}
</tt>
</pre>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0034 [383] and XCU/TC1-2008/0035 [214] are applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0029 [473] and XCU/TC2-2008/0030 [654] are applied.</p>

<h4><a name="tag_23_02_10">  C.2.10  </a>Shell Grammar</h4>

<p>There are several subtle aspects of this grammar where conventional usage implies rules about the grammar that in fact are not
true.</p>

<p>For <i>compound_list</i>, only the forms that end in a <i>separator</i> allow a reserved word to be recognized, so usually only
a <i>separator</i> can be used where a compound list precedes a reserved word (such as <b>Then</b>, <b>Else</b>, <b>Do</b>, and
<b>Rbrace</b>). Explicitly requiring a separator would disallow such valid (if rare) statements as:</p>

<pre>
<tt>if (false) then (echo x) else (echo y) fi
</tt>
</pre>

<p>See the Note under special grammar rule (1).</p>

<p>Concerning the third sentence of rule (1) (``Also, if the parser ...&quot;):</p>

<ul>
<li>
<p>This sentence applies rather narrowly: when a compound list is terminated by some clear delimiter (such as the closing <b>fi</b>
of an inner <b>if_clause</b>) then it would apply; where the compound list might continue (as in after a <tt>';'</tt> ), rule (7a)
(and consequently the first sentence of rule (1)) would apply. In many instances the two conditions are identical, but this part of
rule (1) does not give license to treating a <b>WORD</b> as a reserved word unless it is in a place where a reserved word has to
appear.</p>
</li>

<li>
<p>The statement is equivalent to requiring that when the LR(1) lookahead set contains exactly one reserved word, it must be
recognized if it is present. (Here &quot;LR(1)&quot; refers to the theoretical concepts, not to any real parser generator.)</p>

<p>For example, in the construct below, and when the parser is at the point marked with <tt>'^'</tt>, the only next legal token is
<b>then</b> (this follows directly from the grammar rules):</p>

<pre>
<tt>if if...fi then ... fi
           ^
</tt>
</pre>

<p>At that point, the <b>then</b> must be recognized as a reserved word.</p>

<p>(Depending on the parser generator actually used, &quot;extra&quot; reserved words may be in some lookahead sets. It does not really
matter if they are recognized, or even if any possible reserved word is recognized in that state, because if it is recognized and
is not in the (theoretical) LR(1) lookahead set, an error is ultimately detected. In the example above, if some other reserved word
(for example, <b>while</b>) is also recognized, an error occurs later.</p>

<p>This is approximately equivalent to saying that reserved words are recognized after other reserved words (because it is after a
reserved word that this condition occurs), but avoids the &quot;except for ...&quot; list that would be required for <b>case</b>,
<b>for</b>, and so on. (Reserved words are of course recognized anywhere a <i>simple_command</i> can appear, as well. Other rules
take care of the special cases of non-recognition, such as rule (4) for <b>case</b> statements.)</p>
</li>
</ul>

<p>Note that the body of here-documents are handled by token recognition (see XCU <a href=
"../utilities/V3_chap02.html#tag_18_03"><i>Token Recognition</i></a>) and do not appear in the grammar directly. (However, the
here-document I/O redirection operator is handled as part of the grammar.)</p>

<h5><a name="tag_23_02_10_01"></a>Shell Grammar Lexical Conventions</h5>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0031 [648] and XCU/TC2-2008/0032 [574,646] are applied.</p>

<h5><a name="tag_23_02_10_02"></a>Shell Grammar Rules</h5>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0036 [44] is applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0033 [643,839], XCU/TC2-2008/0034 [643], XCU/TC2-2008/0035 [648],
XCU/TC2-2008/0036 [736], XCU/TC2-2008/0037 [737], XCU/TC2-2008/0038 [581], and XCU/TC2-2008/0039 [735] are applied.</p>

<h4><a name="tag_23_02_11">  C.2.11  </a>Signals and Error Handling</h4>

<p>Historically, some shell implementations silently ignored attempts to use <a href="../utilities/trap.html"><i>trap</i></a> to
set SIGINT or SIGQUIT to the default action or to set a trap for them after they have been set to be ignored by the shell when it
executes an asynchronous subshell (and job control is disabled). This behavior is not conforming. For example, if a shell script
containing the following line is run in the foreground at a terminal:</p>

<pre>
<tt>(trap - INT; exec sleep 10) &amp; wait
</tt>
</pre>

<p>and is then terminated by typing the interrupt character, this standard requires that the <a href=
"../utilities/sleep.html"><i>sleep</i></a> command is terminated by the SIGINT signal.</p>

<p>SD5-XCU-ERN-93 is applied, updating the first paragraph of XCU <a href="../utilities/V3_chap02.html#tag_18_11"><i>Signals and
Error Handling</i></a>.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0040 [750] is applied.</p>

<h4><a name="tag_23_02_12">  C.2.12  </a>Shell Execution Environment</h4>

<p>Some implementations have implemented the last stage of a pipeline in the current environment so that commands such as:</p>

<pre>
<i>command</i> <tt>| read foo
</tt>
</pre>

<p>set variable <b>foo</b> in the current environment. This extension is allowed, but not required; therefore, a shell programmer
should consider a pipeline to be in a subshell environment, but not depend on it.</p>

<p>In early proposals, the description of execution environment failed to mention that each command in a multiple command pipeline
could be in a subshell execution environment. For compatibility with some historical shells, the wording was phrased to allow an
implementation to place any or all commands of a pipeline in the current environment. However, this means that a POSIX application
must assume each command is in a subshell environment, but not depend on it.</p>

<p>The wording about shell scripts is meant to convey the fact that describing &quot;trap actions&quot; can only be understood in the
context of the shell command language. Outside of this context, such as in a C-language program, signals are the operative
condition, not traps.</p>

<p>POSIX.1-2008, Technical Corrigendum 1, XCU/TC1-2008/0037 [238] is applied.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0041 [706] is applied.</p>

<h4><a name="tag_23_02_13">  C.2.13  </a>Pattern Matching Notation</h4>

<p>Pattern matching is a simpler concept and has a simpler syntax than REs, as the former is generally used for the manipulation of
filenames, which are relatively simple collections of characters, while the latter is generally used to manipulate arbitrary text
strings of potentially greater complexity. However, some of the basic concepts are the same, so this section points liberally to
the detailed descriptions in XBD <a href="../basedefs/V1_chap09.html#tag_09"><i>Regular Expressions</i></a>.</p>

<h5><a name="tag_23_02_13_01"></a>Patterns Matching a Single Character</h5>

<p>Both quoting and escaping are described here because pattern matching must work in three separate circumstances:</p>

<ol>
<li>
<p>Calling directly upon the shell, such as in pathname expansion or in a <b>case</b> statement. All of the following match the
string or file <b>abc</b>:</p>

<pre>
<tt>abc "abc" a"b"c a\bc a[b]c a["b"]c a[\b]c a["\b"]c a?c a*c
</tt>
</pre>

<p>The following do not:</p>

<pre>
<tt>"a?c" a\*c a\[b]c
</tt>
</pre>
</li>

<li>
<p>Calling a utility or function without going through a shell, as described for <a href="../utilities/find.html"><i>find</i></a>
and the <a href="../functions/fnmatch.html"><i>fnmatch</i>()</a> function defined in the System Interfaces volume of
POSIX.1-2017.</p>
</li>

<li>
<p>Calling utilities such as <a href="../utilities/find.html"><i>find</i></a>, <i>cpio</i>, <i>tar</i>, or <a href=
"../utilities/pax.html"><i>pax</i></a> through the shell command line. In this case, shell quote removal is performed before the
utility sees the argument. For example, in:</p>

<pre>
<tt>find /bin -name "e\c[\h]o" -print
</tt>
</pre>

<p>after quote removal, the &lt;backslash&gt; characters are presented to <a href="../utilities/find.html"><i>find</i></a> and it
treats them as escape characters. Both precede ordinary characters, so the <i>c</i> and <i>h</i> represent themselves and <a href=
"../utilities/echo.html"><i>echo</i></a> would be found on many historical systems (that have it in <b>/bin</b>). To find a
filename that contained shell special characters or pattern characters, both quoting and escaping are required, such as:</p>

<pre>
<tt>pax -r ... "*a\(\?"
</tt>
</pre>

<p>to extract a filename ending with <tt>"a(?"</tt>.</p>
</li>
</ol>

<p>Conforming applications are required to quote or escape the shell special characters (sometimes called metacharacters). If used
without this protection, syntax errors can result or implementation extensions can be triggered. For example, the KornShell
supports a series of extensions based on parentheses in patterns.</p>

<p>The restriction on a &lt;circumflex&gt; in a bracket expression is to allow implementations that support pattern matching using
the &lt;circumflex&gt; as the negation character in addition to the &lt;exclamation-mark&gt;. A conforming application must use
something like <tt>"[\^!]"</tt> to match either character.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0042 [806] is applied.</p>

<h5><a name="tag_23_02_13_02"></a>Patterns Matching Multiple Characters</h5>

<p>Since each &lt;asterisk&gt; matches zero or more occurrences, the patterns <tt>"a*b"</tt> and <tt>"a**b"</tt> have identical
functionality.</p>

<h5><a name="tag_23_02_13_03"></a>Examples</h5>

<dl compact>
<dt><tt>a[bc]</tt></dt>

<dd>Matches the strings <tt>"ab"</tt> and <tt>"ac"</tt>.</dd>

<dt><tt>a*d</tt></dt>

<dd>Matches the strings <tt>"ad"</tt>, <tt>"abd"</tt>, and <tt>"abcd"</tt>, but not the string <tt>"abc"</tt>.</dd>

<dt><tt>a*d*</tt></dt>

<dd>Matches the strings <tt>"ad"</tt>, <tt>"abcd"</tt>, <tt>"abcdef"</tt>, <tt>"aaaad"</tt>, and <tt>"adddd"</tt>.</dd>

<dt><tt>*a*d</tt></dt>

<dd>Matches the strings <tt>"ad"</tt>, <tt>"abcd"</tt>, <tt>"efabcd"</tt>, <tt>"aaaad"</tt>, and <tt>"adddd"</tt>.</dd>
</dl>

<h5><a name="tag_23_02_13_04"></a>Patterns Used for Filename Expansion</h5>

<p>The caveat about a &lt;slash&gt; within a bracket expression is derived from historical practice. The pattern <tt>"a[b/c]d"</tt>
does not match such pathnames as <b>abd</b> or <b>a/d</b>. On some implementations (including those conforming to the Single UNIX
Specification), it matched a pathname of literally <tt>"a[b/c]d"</tt>. On other systems, it produced an undefined condition (an
unescaped <tt>'['</tt> used outside a bracket expression). In this version, the XSI behavior is now required.</p>

<p>Filenames beginning with a &lt;period&gt; historically have been specially protected from view on UNIX systems. A proposal to
allow an explicit &lt;period&gt; in a bracket expression to match a leading &lt;period&gt; was considered; it is allowed as an
implementation extension, but a conforming application cannot make use of it. If this extension becomes popular in the future, it
will be considered for a future version of the Shell and Utilities volume of POSIX.1-2017.</p>

<p>Historical systems have varied in their permissions requirements. To match <b>f*/bar</b> has required read permissions on the
<b>f*</b> directories in the System&nbsp;V shell, but the Shell and Utilities volume of POSIX.1-2017, the C shell, and KornShell
require only search permissions.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0043 [963] is applied.</p>

<h4><a name="tag_23_02_14">  C.2.14  </a>Special Built-In Utilities</h4>

<p>See the RATIONALE sections on the individual reference pages.</p>

<p>POSIX.1-2008, Technical Corrigendum 2, XCU/TC2-2008/0044 [882] and XCU/TC2-2008/0045 [654] are applied.</p>

<p>&nbsp;</p>

<a href="#top"><span class="topOfPage">return to top of page</span></a><br>
<hr size="2" noshade>
<center><font size="2">UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
Copyright &copy; 2001-2018 IEEE and The Open Group, All Rights Reserved<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../functions/contents.html">XSH</a> | <a href="../utilities/contents.html">XCU</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<hr size="2" noshade>
<div class="NAVHEADER">
<table summary="Header navigation table" class="nav" width="100%" border="0" cellpadding="0" cellspacing="0">
<tr class="nav">
<td class="nav" width="15%" align="left" valign="bottom"><a href="../xrat/V4_xcu_chap01.html" accesskey="P">&lt;&lt;&lt;
Previous</a></td>
<td class="nav" width="70%" align="center" valign="bottom"><a href="contents.html">Home</a></td>
<td class="nav" width="15%" align="right" valign="bottom"><a href="../xrat/V4_xcu_chap03.html" accesskey="N">Next
&gt;&gt;&gt;</a></td>
</tr>
</table>

<hr align="LEFT" width="100%">
</div>
</body>
</html>

